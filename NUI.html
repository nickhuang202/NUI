<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port Configuration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #4a5f7f 0%, #3d4f66 100%);
            border-radius: 12px;
            padding: 20px 30px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .tab-navigation {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-radius: 12px;
            padding: 15px 30px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .tab-btn {
            padding: 12px 30px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            color: #ecf0f1;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: capitalize;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #4CAF50;
            transform: translateY(-2px);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .platform-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* service indicator LEDs */
        .service-indicators {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-left: 12px;
        }

        .version-display {
            margin-left: auto;
            color: #4CAF50;
            font-weight: bold;
            font-size: 14px;
            padding: 6px 12px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 6px;
        }

        .service-indicator {
            display: flex;
            gap: 8px;
            align-items: center;
            color: #ecf0f1;
            font-size: 12px;
        }

        .service-indicator .led {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.6) inset;
            transition: box-shadow 0.12s, background 0.12s;
        }

        .service-indicator .led.blue {
            background: rgba(66, 133, 244, 0.9);
            color: rgba(66, 133, 244, 0.9);
        }

        .service-indicator .led.green {
            background: rgba(76, 175, 80, 0.95);
            color: rgba(76, 175, 80, 0.95);
        }

        .service-indicator .led.off {
            opacity: 0.35;
            filter: grayscale(80%);
        }

        @keyframes ledBlink {
            0% {
                box-shadow: 0 0 2px rgba(255, 255, 255, 0.05), 0 0 6px rgba(255, 255, 255, 0.02);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.08), 0 0 18px currentColor;
                transform: scale(1.08);
            }

            100% {
                box-shadow: 0 0 2px rgba(255, 255, 255, 0.05), 0 0 6px rgba(255, 255, 255, 0.02);
                transform: scale(1);
            }
        }

        .service-indicator .led.blink {
            animation: ledBlink 1s linear infinite;
        }

        .platform-btn {
            padding: 10px 20px;
            border: 2px solid #4CAF50;
            background: transparent;
            color: #4CAF50;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .platform-btn:hover {
            background: rgba(76, 175, 80, 0.1);
            transform: translateY(-2px);
        }

        .platform-btn.active {
            background: #4CAF50;
            color: white;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .status {
            color: #ecf0f1;
            font-size: 13px;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 180px;
            overflow-y: auto;
            line-height: 1.5;
            min-height: 40px;
        }

        .status::-webkit-scrollbar {
            width: 8px;
        }

        .status::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .status::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.5);
            border-radius: 4px;
        }

        .status::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.7);
        }

        .message-bar {
            margin: 20px 0 10px 0;
            display: block;
            width: 100%;
        }

        .clear-btn {
            padding: 8px 16px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .clear-btn:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        /* Modal styles for file selection */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            color: white;
            position: relative;
            z-index: 10000;
        }

        .modal-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #4CAF50;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .file-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
        }

        .file-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .file-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4CAF50;
            transform: translateX(5px);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .modal-btn.cancel {
            background: #95a5a6;
            color: white;
        }

        .modal-btn.cancel:hover {
            background: #7f8c8d;
        }

        .modal-btn.load {
            background: #2196F3;
            color: white;
        }

        .modal-btn.load:hover {
            background: #1976D2;
        }

        .modal-btn.save {
            background: #FF9800;
            color: white;
        }

        .modal-btn.save:hover {
            background: #F57C00;
        }

        .topology-input {
            width: 100%;
            padding: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
            transition: all 0.3s;
        }

        .topology-input:focus {
            outline: none;
            border-color: #4CAF50;
            background: rgba(0, 0, 0, 0.4);
        }

        .topology-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Transceiver Info Page Styles */
        .transceiver-container {
            background: linear-gradient(135deg, #1e2a3a 0%, #16202e 100%);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            color: #ecf0f1;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 14px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 7px;
            padding: 14px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .summary-card .label {
            font-size: 10px;
            opacity: 0.8;
            margin-bottom: 6px;
        }

        .summary-card .value {
            font-size: 25px;
            font-weight: bold;
        }

        .summary-card .percent {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 4px;
        }

        .summary-card.good {
            border-left: 4px solid #4CAF50;
        }

        .summary-card.warning {
            border-left: 4px solid #FFC107;
        }

        .summary-card.critical {
            border-left: 4px solid #F44336;
        }

        .table-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 600px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .transceiver-container table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            min-width: 1400px;
        }

        .transceiver-container th {
            background: rgba(255, 255, 255, 0.08);
            padding: 14px 10px;
            text-align: left;
            font-weight: bold;
            color: #bdc3c7;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .transceiver-container th:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .transceiver-container th.sortable::after {
            content: ' ‚áÖ';
            opacity: 0.3;
            font-size: 11px;
        }

        .transceiver-container th.sort-asc::after {
            content: ' ‚ñ≤';
            opacity: 1;
            color: #4CAF50;
        }

        .transceiver-container th.sort-desc::after {
            content: ' ‚ñº';
            opacity: 1;
            color: #4CAF50;
        }

        .transceiver-container td {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            white-space: nowrap;
        }

        /* Scrollbar styling for table container */
        .table-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .table-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .table-container::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.5);
            border-radius: 5px;
        }

        .table-container::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.7);
        }

        .transceiver-container tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .transceiver-container tr.good {
            background: rgba(76, 175, 80, 0.1);
        }

        .transceiver-container tr.warning {
            background: rgba(255, 193, 7, 0.1);
        }

        .transceiver-container tr.critical {
            background: rgba(244, 67, 54, 0.15);
        }

        /* View Switcher Styles */
        .view-type-btn:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: #4CAF50 !important;
            transform: translateY(-2px);
        }

        .view-type-btn.active {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important;
            border-color: #4CAF50 !important;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }

        /* Port Map View Styles */
        .port-map-view {
            margin-top: 20px;
        }

        .port-map-grid {
            display: grid;
            grid-template-rows: repeat(4, auto);
            grid-auto-flow: column;
            gap: 12px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            justify-content: start;
        }

        .port-map-card {
            width: 75px;
            height: 85px;
            background: rgba(84, 110, 122, 0.45);
            border-radius: 8px;
            border: 2px solid;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            padding: 6px;
        }

        .port-map-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .port-map-card.good {
            border-color: #4CAF50;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.12) 0%, rgba(76, 175, 80, 0.06) 100%);
        }

        .port-map-card.critical {
            border-color: #F44336;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.12) 0%, rgba(244, 67, 54, 0.06) 100%);
            animation: pulse-critical-glow 1.5s ease-in-out infinite;
        }

        @keyframes pulse-critical-glow {

            0%,
            100% {
                box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3), 0 0 0 0 rgba(244, 67, 54, 0.7);
                border-color: #F44336;
            }

            50% {
                box-shadow: 0 4px 20px rgba(244, 67, 54, 0.6), 0 0 0 4px rgba(244, 67, 54, 0.3);
                border-color: #ff5252;
            }
        }

        .port-map-card.warning {
            border-color: #FFC107;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.12) 0%, rgba(255, 193, 7, 0.06) 100%);
            animation: pulse-warning-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-warning-glow {

            0%,
            100% {
                box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3), 0 0 0 0 rgba(255, 193, 7, 0.5);
                border-color: #FFC107;
            }

            50% {
                box-shadow: 0 4px 15px rgba(255, 193, 7, 0.5), 0 0 0 3px rgba(255, 193, 7, 0.2);
                border-color: #ffd54f;
            }
        }

        .port-map-card .port-number {
            font-size: 8px;
            font-weight: bold;
            color: #ecf0f1;
            margin-bottom: 3px;
            text-align: center;
            line-height: 1.1;
            text-transform: uppercase;
        }

        .port-map-card .vendor-name {
            font-size: 10px;
            color: #ffffff;
            text-align: center;
            font-weight: bold;
            letter-spacing: 0.3px;
            padding: 3px 5px;
            border-radius: 4px;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .port-map-card .temp-indicator {
            position: absolute;
            top: 3px;
            right: 3px;
            font-size: 7px;
            color: #95a5a6;
            background: rgba(0, 0, 0, 0.6);
            padding: 1px 3px;
            border-radius: 2px;
            line-height: 1;
        }

        .port-map-card .status-dot {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }

        .port-map-card.good .status-dot {
            background: #4CAF50;
        }

        .port-map-card.warning .status-dot {
            background: #FFC107;
        }

        .port-map-card.critical .status-dot {
            background: #F44336;
        }

        /* Vendor-based card colors */
        .port-map-card.vendor-eoptolink {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.25) 0%, rgba(59, 130, 246, 0.15) 100%);
        }

        .port-map-card.vendor-eoptolink .vendor-name {
            background: rgba(59, 130, 246, 0.6);
            color: #ffffff;
        }

        .port-map-card.vendor-finisar {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.25) 0%, rgba(236, 72, 153, 0.15) 100%);
        }

        .port-map-card.vendor-finisar .vendor-name {
            background: rgba(236, 72, 153, 0.6);
            color: #ffffff;
        }

        .port-map-card.vendor-innolight {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.25) 0%, rgba(168, 85, 247, 0.15) 100%);
        }

        .port-map-card.vendor-innolight .vendor-name {
            background: rgba(168, 85, 247, 0.6);
            color: #ffffff;
        }

        .port-map-card.vendor-intel {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.25) 0%, rgba(16, 185, 129, 0.15) 100%);
        }

        .port-map-card.vendor-intel .vendor-name {
            background: rgba(16, 185, 129, 0.6);
            color: #ffffff;
        }

        .port-map-card.vendor-unknown {
            background: linear-gradient(135deg, rgba(100, 116, 139, 0.25) 0%, rgba(100, 116, 139, 0.15) 100%);
        }

        .port-map-card.vendor-unknown .vendor-name {
            background: rgba(100, 116, 139, 0.6);
            color: #ffffff;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-badge.good {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .status-badge.warning {
            background: rgba(255, 193, 7, 0.2);
            color: #FFC107;
        }

        .status-badge.critical {
            background: rgba(244, 67, 54, 0.2);
            color: #F44336;
        }

        .highlight-warning {
            color: #FFC107;
            font-weight: bold;
        }

        .highlight-critical {
            color: #F44336;
            font-weight: bold;
        }

        .status-bar {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.7;
            white-space: pre-wrap;
        }

        .reference-section {
            margin-top: 30px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
        }

        .reference-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .reference-card {
            background: rgba(255, 255, 255, 0.03);
            padding: 16px;
            border-radius: 8px;
        }

        .reference-card h3 {
            margin-bottom: 12px;
            color: #4CAF50;
            font-size: 18px;
        }

        .ref-line {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        /* Vendor Color Badges */
        .vendor-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 12px;
            text-transform: uppercase;
        }

        .vendor-eoptolink {
            background: rgba(59, 130, 246, 0.2);
            color: #3B82F6;
            border: 1px solid rgba(59, 130, 246, 0.4);
        }

        .vendor-finisar {
            background: rgba(236, 72, 153, 0.2);
            color: #EC4899;
            border: 1px solid rgba(236, 72, 153, 0.4);
        }

        .vendor-innolight {
            background: rgba(168, 85, 247, 0.2);
            color: #A855F7;
            border: 1px solid rgba(168, 85, 247, 0.4);
        }

        .vendor-intel {
            background: rgba(34, 197, 94, 0.2);
            color: #22C55E;
            border: 1px solid rgba(34, 197, 94, 0.4);
        }

        .vendor-unknown {
            background: rgba(148, 163, 184, 0.2);
            color: #94A3B8;
            border: 1px solid rgba(148, 163, 184, 0.4);
        }

        /* Vendor Legend */
        .vendor-legend {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .vendor-legend-title {
            font-weight: bold;
            color: #4CAF50;
            margin-right: 10px;
        }

        .file-item.selected {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .main-container {
            background: linear-gradient(135deg, #1e2a3a 0%, #16202e 100%);
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        .port-grid {
            display: grid;
            gap: 12px;
            justify-content: start;
            position: relative;
            z-index: 2;
        }

        .port-grid.minipack-layout {
            grid-template-columns: repeat(16, 75px);
            grid-template-rows: repeat(4, auto);
            grid-auto-flow: column;
        }

        .port-grid.wedge-layout {
            grid-template-columns: repeat(9, 75px);
            grid-template-rows: repeat(4, auto);
            grid-auto-flow: column;
        }

        .port-container {
            width: 75px;
            height: 85px;
            background: rgba(84, 110, 122, 0.45);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .port-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .inner-frame {
            width: 90%;
            height: 90%;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            border: 2px solid;
        }

        .inner-frame.profile-50 {
            border-color: #C0C0C0;
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.16) 0%, rgba(192, 192, 192, 0.08) 100%);
        }

        .inner-frame.profile-45 {
            border-color: #3d3d3d;
            background: linear-gradient(135deg, rgba(61, 61, 61, 0.16) 0%, rgba(61, 61, 61, 0.08) 100%);
        }

        .inner-frame.profile-35 {
            border-color: #3d3d3d;
            background: linear-gradient(135deg, rgba(61, 61, 61, 0.16) 0%, rgba(61, 61, 61, 0.08) 100%);
        }

        .inner-frame.profile-39 {
            border-color: #4CAF50;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.12) 0%, rgba(76, 175, 80, 0.06) 100%);
        }

        .inner-frame.profile-38 {
            border-color: #90EE90;
            background: linear-gradient(135deg, rgba(144, 238, 144, 0.16) 0%, rgba(144, 238, 144, 0.08) 100%);
        }

        .inner-frame.profile-35 {
            border-color: #0bf00b;
            background: linear-gradient(135deg, rgba(144, 238, 144, 0.16) 0%, rgba(144, 238, 144, 0.08) 100%);
        }

        .inner-frame.profile-25 {
            border-color: #1565C0;
            background: linear-gradient(135deg, rgba(21, 101, 192, 0.16) 0%, rgba(21, 101, 192, 0.08) 100%);
        }

        .inner-frame.profile-23 {
            border-color: #64B5F6;
            background: linear-gradient(135deg, rgba(100, 181, 246, 0.16) 0%, rgba(100, 181, 246, 0.08) 100%);
        }

        .inner-frame.profile-47 {
            border-color: #64B5F6;
            background: linear-gradient(135deg, rgba(100, 181, 246, 0.16) 0%, rgba(100, 181, 246, 0.08) 100%);
        }

        .port-slot {
            background: #607d8b;
            border: 1px solid #455a64;
            border-radius: 4px;
            padding: 3px 4px;
            text-align: center;
            font-weight: bold;
            color: #ecf0f1;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin: 1px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            min-height: 24px;
        }

        .port-slot .port-name {
            font-size: 9px;
            font-weight: bold;
            white-space: nowrap;
            line-height: 1.2;
        }

        .port-slot .port-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            gap: 3px;
        }

        .port-slot .speed-label {
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 7px;
            font-weight: bold;
            white-space: nowrap;
            line-height: 1.1;
        }

        .port-slot .profile-label {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 7px;
            font-weight: bold;
            white-space: nowrap;
            line-height: 1.1;
        }

        .port-slot:hover {
            background: #78909c;
            border-color: #FFD700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        /* glowing animation for hovered connections */
        @keyframes glowPulse {
            0% {
                filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
            }

            50% {
                filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.9));
            }

            100% {
                filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
            }
        }

        .connection-glow {
            animation: glowPulse 1s ease-in-out infinite;
        }

        .port-slot.glowing {
            animation: glowPulse 1s ease-in-out infinite;
        }

        .port-slot.selected {
            border: 2px solid #FFD700;
            box-shadow: 0 0 12px #FFD700;
            background: #78909c;
        }

        .port-slot.connected {
            border-color: #FFD700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        .port-slot.hidden {
            display: none;
        }

        /* Port status coloring */
        .port-slot.link-up {
            background: rgba(255, 193, 7, 0.3) !important;
            border-color: #FFC107 !important;
            box-shadow: 0 0 8px rgba(255, 193, 7, 0.5) !important;
        }

        .port-slot.link-down {
            background: rgba(128, 128, 128, 0.2) !important;
            border-color: #808080 !important;
            opacity: 0.6;
        }

        .port-slot.link-error {
            background: rgba(244, 67, 54, 0.25) !important;
            border-color: #F44336 !important;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.55) !important;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        /* Red border flash animation for Run Test tab when test is running */
        @keyframes redBorderFlash {

            0%,
            100% {
                border-color: #e74c3c;
                box-shadow: 0 0 10px rgba(231, 76, 60, 0.6);
            }

            50% {
                border-color: #c0392b;
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.9);
            }
        }

        .tab-btn.test-running {
            animation: redBorderFlash 1.5s ease-in-out infinite;
            border-color: #e74c3c !important;
        }

        /* Upstream/downstream group boxes */
        .group-box {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            padding: 8px;
            pointer-events: none;
            z-index: 3;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.02));
        }

        .group-box .label {
            position: absolute;
            top: -18px;
            left: 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            text-transform: lowercase;
            opacity: 0.95;
        }

        .connection-line {
            stroke: #FFD700;
            stroke-width: 2.5;
            fill: none;
            filter: drop-shadow(0 0 4px #FFD700);
        }
    </style>
    <!-- CACHE_BUST:1770169001 -->
</head>

<body>
    <!-- AVARUNTAR Logo Banner -->
    <div
        style="display: flex; align-items: center; justify-content: center; padding: 20px 0 10px 0; position: relative;">
        <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjE1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGV4dCB4PSIyMDAiIHk9Ijc1IiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iNDgiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjNENBRjUwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5BVkFSVU5UQVI8L3RleHQ+PHRleHQgeD0iMjAwIiB5PSIxMTAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk1YTVhNiIgdGV4dC1hbmNob3I9Im1pZGRsZSI+QWNjdG9uIFZlcnNhdGlsZSBBdXRvbWF0ZWQgUlVOIFRlc3RpbmcgQW5kIFJlcG9ydGluZzwvdGV4dD48L3N2Zz4="
            alt="AVARUNTAR" style="max-width: 280px; width: 100%; height: auto;">
        <div class="version-display" id="versionDisplay" style="position: absolute; right: 20px;"></div>
    </div>

    <div class="header">
        <div class="platform-selector">
            <button class="platform-btn active" onclick="switchPlatform('MINIPACK3N', event)">MINIPACK3N</button>
            <button class="platform-btn" onclick="switchPlatform('MINIPACK3BA', event)">MINIPACK3BA</button>
            <button class="platform-btn" onclick="switchPlatform('WEDGE800BACT', event)">WEDGE800BACT</button>
            <button class="platform-btn" onclick="switchPlatform('WEDGE800CACT', event)">WEDGE800CACT</button>
        </div>
        <div class="service-indicators" aria-hidden="false">
            <div class="service-indicator" title="qsfp_service status">
                <div class="led blue off" id="qsfpLed"></div>
                <div class="label-text">qsfp_service</div>
            </div>
            <div class="service-indicator" title="sai_mono_link_test-sai_impl status">
                <div class="led green off" id="saiLed"></div>
                <div class="label-text">sai_mono_link_test</div>
            </div>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-navigation">
        <button class="tab-btn active" onclick="switchTab('topology')">Port Topology Config</button>
        <button class="tab-btn" onclick="switchTab('transceiver')">Transceiver Info</button>
        <button class="tab-btn" onclick="switchTab('testinfo')">Test Info</button>
        <button class="tab-btn" onclick="switchTab('runtest')">Run Test</button>
        <button class="tab-btn" onclick="window.open('/dashboard', '_blank')">Dashboard</button>
        <button class="tab-btn" onclick="window.location.href='/lab_monitor'"
            style="background: linear-gradient(135deg, #e67e22 0%, #d35400 100%); border-color: #e67e22;">Lab
            Monitor</button>
    </div>

    <!-- Modal for file selection -->
    <div class="modal-overlay" id="fileSelectionModal">
        <div class="modal-content">
            <div class="modal-header">Topology Management - <span id="modalPlatformName"></span></div>
            <div class="modal-body">
                <div class="file-list" id="fileList">
                    <div style="text-align: center; color: #95a5a6;">Loading...</div>
                </div>
                <div style="margin-top: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #4CAF50; font-weight: bold;">File
                        Name:</label>
                    <input type="text" id="topologyFileName" class="topology-input"
                        placeholder="Enter file name (e.g., my_topology.materialized_JSON)" />
                    <div id="selectedFileDisplay" style="margin-top: 8px; color: #3498db; font-size: 13px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn load" onclick="loadSelectedTopology()"
                    title="Load selected or entered topology file">‚§ì LOAD</button>
                <button class="modal-btn save" onclick="saveCurrentTopology()"
                    title="Save current topology to specified file">üíæ SAVE</button>
                <button class="modal-btn cancel" onclick="closeFileSelectionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Topology Tab Content -->
    <div class="tab-content active" id="topologyTab">
        <!-- Topology Controls -->
        <div class="controls" style="margin-bottom: 20px; display: flex; gap: 15px; justify-content: flex-end;">
            <button class="clear-btn" onclick="showTopologyFileSelector()" style="background: #2196F3;">
                ‚§ì Topology mgmt
            </button>
            <button class="clear-btn" onclick="applyTopologyConfig()" style="background: #9C27B0;">
                ‚öôÔ∏è Apply topology
            </button>
            <button class="clear-btn" onclick="quickConnect()" style="background: #4CAF50;">
                ‚ö° Quick Connect
            </button>
            <button class="clear-btn" onclick="clearAllConnections()">Clear Connections</button>
        </div>

        <div class="main-container" id="mainContainer">
            <svg id="connectionSvg"></svg>
            <div id="groupBoxes"></div>
            <div class="port-grid" id="portGrid"></div>
        </div>

        <!-- Status bar below port connection area -->
        <div class="status message-bar" id="status">Click port buttons to create connections</div>
    </div>

    <!-- Transceiver Info Tab Content -->
    <div class="tab-content" id="transceiverTab">
        <div class="transceiver-container">
            <!-- View Type Switcher -->
            <div class="view-switcher"
                style="display: flex; gap: 10px; margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                <button class="view-type-btn active" onclick="switchTransceiverView('list')"
                    style="padding: 10px 25px; border: 2px solid rgba(255,255,255,0.2); background: rgba(76, 175, 80, 0.3); color: #ecf0f1; border-radius: 6px; cursor: pointer; font-weight: bold; transition: all 0.3s;">List
                    Type</button>
                <button class="view-type-btn" onclick="switchTransceiverView('portmap')"
                    style="padding: 10px 25px; border: 2px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.2); color: #ecf0f1; border-radius: 6px; cursor: pointer; font-weight: bold; transition: all 0.3s;">Port
                    Map Type</button>
            </div>

            <!-- Vendor Legend -->
            <div class="vendor-legend">
                <span class="vendor-legend-title">Vendor Labels:</span>
                <span class="vendor-badge vendor-eoptolink">Eoptolink</span>
                <span class="vendor-badge vendor-finisar">FINISAR</span>
                <span class="vendor-badge vendor-innolight">INNOLIGHT</span>
                <span class="vendor-badge vendor-intel">INTEL</span>
            </div>

            <!-- Summary Cards -->
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="label">Total Ports</div>
                    <div class="value" id="totalPorts">-</div>
                </div>
                <div class="summary-card good">
                    <div class="label">Good</div>
                    <div class="value" id="goodPorts">-</div>
                    <div class="percent" id="goodPercent">-</div>
                </div>
                <div class="summary-card warning">
                    <div class="label">Warning</div>
                    <div class="value" id="warningPorts">-</div>
                    <div class="percent" id="warningPercent">-</div>
                </div>
                <div class="summary-card critical">
                    <div class="label">Critical</div>
                    <div class="value" id="criticalPorts">-</div>
                    <div class="percent" id="criticalPercent">-</div>
                </div>
            </div>

            <!-- Port Map View Container -->
            <div id="portMapView" class="port-map-view" style="display: none;">
                <div id="portMapGrid" class="port-map-grid">
                    <div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #95a5a6;">Loading Port
                        Map...</div>
                </div>
            </div>

            <!-- Summary Table -->
            <div id="listView" class="table-container">
                <table id="transceiverTable">
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTransceiverTable(0)">Port</th>
                            <th class="sortable" onclick="sortTransceiverTable(1)">Vendor</th>
                            <th class="sortable" onclick="sortTransceiverTable(2)">Serial</th>
                            <th class="sortable" onclick="sortTransceiverTable(3)">Part Number</th>
                            <th class="sortable" onclick="sortTransceiverTable(4)" style="text-align: center;">Status
                            </th>
                            <th class="sortable" onclick="sortTransceiverTable(5)" style="text-align: right;">Temp (¬∞C)
                            </th>
                            <th class="sortable" onclick="sortTransceiverTable(6)" style="text-align: right;">TX Avg
                                (dBm)</th>
                            <th class="sortable" onclick="sortTransceiverTable(7)" style="text-align: right;">RX Avg
                                (dBm)</th>
                            <th class="sortable" onclick="sortTransceiverTable(8)" style="text-align: right;">TX Range
                                (dB)</th>
                            <th class="sortable" onclick="sortTransceiverTable(9)" style="text-align: right;">RX Range
                                (dB)</th>
                            <th class="sortable" onclick="sortTransceiverTable(10)">FW App Ver</th>
                            <th class="sortable" onclick="sortTransceiverTable(11)">FW DSP Ver</th>
                            <th class="sortable" onclick="sortTransceiverTable(12)" style="text-align: right;">Issues
                            </th>
                        </tr>
                    </thead>
                    <tbody id="transceiverTableBody">
                        <tr>
                            <td colspan="13" style="text-align: center; padding: 40px; color: #95a5a6;">
                                Loading... or No Data
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Critical Issues Highlight -->
            <div class="status-bar" id="issuesSummary">
                <strong>Critical Issues Summary</strong>

                Loading...
            </div>

            <!-- Reference Standards -->
            <div class="reference-section">
                <h2 style="margin-bottom: 20px; color: #4CAF50;">Reference Standards</h2>
                <div class="reference-grid">
                    <div class="reference-card">
                        <h3>400G FR4 (Mainstream)</h3>
                        <div class="ref-line"><span>TX Power Spec Range</span><strong>-8.0 ~ 4.5 dBm</strong></div>
                        <div class="ref-line"><span>RX Power Spec Range</span><strong>-13.0 ~ 4.5 dBm</strong></div>
                        <div class="ref-line"><span>Recommended TX Safe Range</span><strong style="color:#4CAF50;">-6.0
                                ~ 3.0 dBm</strong></div>
                        <div class="ref-line"><span>Recommended RX Safe Range</span><strong style="color:#4CAF50;">-10.0
                                ~ 3.0 dBm</strong></div>
                    </div>
                    <div class="reference-card">
                        <h3>100G CWDM4</h3>
                        <div class="ref-line"><span>TX Power Spec Range</span><strong>-4.3 ~ 4.5 dBm</strong></div>
                        <div class="ref-line"><span>RX Power Spec Range</span><strong>-12.6 ~ 4.5 dBm</strong></div>
                        <div class="ref-line"><span>Recommended TX Safe Range</span><strong style="color:#4CAF50;">-3.0
                                ~ 3.0 dBm</strong></div>
                        <div class="ref-line"><span>Recommended RX Safe Range</span><strong style="color:#4CAF50;">-10.0
                                ~ 3.0 dBm</strong></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Test Info Tab Content -->
    <div class="tab-content" id="testinfoTab">
        <div class="container">
            <div class="config-section">
                <div class="section-header">
                    <h2>Hardware Test Status</h2>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button id="autoRefreshToggle" class="apply-btn" onclick="toggleAutoRefresh()"
                            style="min-width: 150px;">‚è∏Ô∏è Auto Refresh: ON</button>
                        <button class="apply-btn" onclick="refreshTestInfo()" style="min-width: 150px;">üîÑ
                            Refresh</button>
                    </div>
                </div>

                <div id="testStatusBox" class="status-box" style="padding: 20px;">
                    <div style="text-align: center; color: #95a5a6;">Loading test status...</div>
                </div>

                <div id="testResultsSection" style="display: none; margin-top: 20px;">
                    <div class="section-header">
                        <h2>Test Results</h2>
                    </div>
                    <div class="table-container">
                        <table class="port-table">
                            <thead>
                                <tr>
                                    <th style="width: 80px;">#</th>
                                    <th>Test Name</th>
                                    <th style="width: 120px;">Result</th>
                                </tr>
                            </thead>
                            <tbody id="testResultsTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>

                <div id="logViewerSection" style="display: none; margin-top: 20px;">
                    <div class="section-header">
                        <h2>Live Log Viewer</h2>
                        <div style="display: flex; gap: 10px;">
                            <button class="apply-btn" onclick="toggleLogViewer()" style="min-width: 120px;"
                                id="logViewerToggleBtn">Show Log</button>
                            <button class="apply-btn" onclick="refreshLogViewer()" style="min-width: 120px;">üîÑ
                                Refresh</button>
                        </div>
                    </div>
                    <div id="logViewerContent"
                        style="display: none; background: #1a1a1a; padding: 15px; border-radius: 8px; margin-top: 10px;">
                        <div style="margin-bottom: 10px; color: #95a5a6; font-size: 12px;">
                            <span id="logViewerInfo">Loading...</span>
                        </div>
                        <div id="logViewerText"
                            style="font-family: 'Courier New', monospace; font-size: 11px; color: #ecf0f1; background: #000; padding: 15px; border-radius: 4px; max-height: 500px; overflow-y: auto; white-space: pre-wrap;">
                            Loading log content...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Run Test Tab Content -->
    <div class="tab-content" id="runtestTab">
        <div class="container">
            <div class="config-section">
                <div class="section-header">
                    <h2>üöÄ Run Test Configuration</h2>
                    <div id="testRunningIndicator"
                        style="display: none; padding: 8px 16px; background: rgba(76, 175, 80, 0.2); border: 2px solid #4CAF50; border-radius: 6px; color: #4CAF50; font-weight: bold; animation: pulse 2s ease-in-out infinite;">
                        ‚ö° Test Running...
                    </div>
                </div>

                <!-- Load Saved Test Procedure -->
                <div style="margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #2196F3; font-weight: bold; font-size: 14px;">
                        üìÅ Load Saved Test Procedure (Optional)
                    </label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="savedProcedureSelect" class="topology-input" onchange="loadSavedProcedure()"
                            style="flex: 1; padding: 12px; font-size: 14px;">
                            <option value="">-- Select Saved Procedure --</option>
                        </select>
                        <button onclick="refreshSavedProcedures()" class="apply-btn"
                            style="min-width: 120px; background: #2196F3;">üîÑ Refresh</button>
                        <button onclick="deleteSavedProcedure()" class="apply-btn"
                            style="min-width: 120px; background: #F44336;">üóëÔ∏è Delete</button>
                    </div>
                </div>

                <!-- Test Script Selection -->
                <div style="margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #4CAF50; font-weight: bold; font-size: 14px;">
                        1. Test Script List
                    </label>
                    <select id="testScriptSelect" class="topology-input"
                        onchange="onTestScriptChange(); saveRunTestSelections();"
                        style="width: 100%; padding: 12px; font-size: 14px;">
                        <option value="">-- Select Test Script --</option>
                    </select>
                </div>

                <!-- File Upload (Hidden by default, shown for run_all_test.sh) -->
                <div id="fileUploadSection" style="display: none; margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #FF9800; font-weight: bold; font-size: 14px;">
                        üì§ Upload Custom .zst File (Optional)
                    </label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="binFileInput" accept=".zst"
                            style="flex: 1; padding: 10px; background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer;">
                        <button onclick="uploadBinFile()" class="apply-btn"
                            style="min-width: 120px; background: #FF9800;">Upload</button>
                    </div>
                    <div id="uploadStatus" style="margin-top: 8px; font-size: 12px; color: #95a5a6;"></div>

                    <!-- Progress Bar -->
                    <div id="uploadProgressContainer"
                        style="display: none; margin-top: 10px; width: 100%; background-color: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                        <div id="uploadProgressBar"
                            style="width: 0%; height: 8px; background-color: #4CAF50; transition: width 0.2s;"></div>
                    </div>
                    <div id="uploadPercentage"
                        style="display: none; font-size: 11px; text-align: right; color: #bbb; margin-top: 2px;">0%
                    </div>
                </div>

                <!-- Bin List -->
                <div style="margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #4CAF50; font-weight: bold; font-size: 14px;">
                        2. Bin List (.zst files)
                    </label>
                    <select id="binFileSelect" class="topology-input" onchange="saveRunTestSelections();"
                        style="width: 100%; padding: 12px; font-size: 14px;">
                        <option value="">-- Select Bin File --</option>
                    </select>
                    <div id="binFileInfo" style="margin-top: 8px; font-size: 12px; color: #95a5a6;"></div>
                </div>

                <!-- Test Level (for SAI_TX_test.sh and Agent_HW_TX_test.sh) -->
                <div id="testLevelSection" style="display: none; margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #4CAF50; font-weight: bold; font-size: 14px;">
                        3. Level List
                    </label>
                    <select id="testLevelSelect" class="topology-input" onchange="saveRunTestSelections();"
                        style="width: 100%; padding: 12px; font-size: 14px;">
                        <option value="">-- Select Test Level --</option>
                        <option value="t0">T0</option>
                        <option value="t1">T1</option>
                        <option value="t2">T2</option>
                    </select>
                </div>

                <!-- Test Items Selection (for run_all_test.sh) -->
                <div id="testItemsSection" style="display: none; margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #4CAF50; font-weight: bold; font-size: 14px;">
                        3. Select Test Items
                    </label>
                    <div
                        style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; border: 2px solid rgba(76, 175, 80, 0.3);">
                        <!-- SAI Test -->
                        <div style="margin-bottom: 15px;">
                            <label
                                style="display: flex; align-items: center; cursor: pointer; color: #ecf0f1; font-weight: bold;">
                                <input type="checkbox" id="saiTestCheckbox" checked
                                    onchange="toggleTestLevels('sai'); saveRunTestSelections();"
                                    style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;">
                                <span style="font-size: 14px;">SAI Test</span>
                            </label>
                            <div id="saiLevels" style="margin-left: 35px; margin-top: 8px; display: flex; gap: 15px;">
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="saiT0Checkbox" class="sai-level" value="t0" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T0</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="saiT1Checkbox" class="sai-level" value="t1" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T1</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="saiT2Checkbox" class="sai-level" value="t2" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T2</span>
                                </label>
                            </div>
                        </div>

                        <!-- Agent HW Test -->
                        <div style="margin-bottom: 15px;">
                            <label
                                style="display: flex; align-items: center; cursor: pointer; color: #ecf0f1; font-weight: bold;">
                                <input type="checkbox" id="agentHwTestCheckbox" checked
                                    onchange="toggleTestLevels('agenthw'); saveRunTestSelections();"
                                    style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;">
                                <span style="font-size: 14px;">Agent HW Test</span>
                            </label>
                            <div id="agentHwLevels"
                                style="margin-left: 35px; margin-top: 8px; display: flex; gap: 15px;">
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="agentT0Checkbox" class="agenthw-level" value="t0" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T0</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="agentT1Checkbox" class="agenthw-level" value="t1" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T1</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="agentT2Checkbox" class="agenthw-level" value="t2" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T2</span>
                                </label>
                            </div>
                        </div>

                        <!-- Link Test -->
                        <div style="margin-bottom: 15px;">
                            <label
                                style="display: flex; align-items: center; cursor: pointer; color: #ecf0f1; font-weight: bold;">
                                <input type="checkbox" id="linkTestCheckbox" checked
                                    onchange="toggleTestLevels('link'); saveRunTestSelections();"
                                    style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;">
                                <span style="font-size: 14px;">Link Test</span>
                            </label>
                            <div id="linkLevels" style="margin-left: 35px; margin-top: 8px; display: flex; gap: 15px;">
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="linkT0Checkbox" class="link-level" value="t0" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T0</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer; color: #95a5a6;">
                                    <input type="checkbox" id="linkT1Checkbox" class="link-level" value="t1" checked
                                        onchange="saveRunTestSelections()"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                                    <span style="font-size: 13px;">T1</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: not-allowed; color: #666;">
                                    <input type="checkbox" id="linkT2Checkbox" class="link-level" value="t2" disabled
                                        data-permanently-disabled="true"
                                        style="width: 16px; height: 16px; margin-right: 6px; cursor: not-allowed; opacity: 0.5;">
                                    <span style="font-size: 13px;">T2</span>
                                </label>
                            </div>
                        </div>

                        <!-- EVT Exit Test -->
                        <div style="margin-bottom: 0px;">
                            <label
                                style="display: flex; align-items: center; cursor: pointer; color: #ecf0f1; font-weight: bold;">
                                <input type="checkbox" id="evtTestCheckbox" checked onchange="saveRunTestSelections()"
                                    style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;">
                                <span style="font-size: 14px;">EVT Exit Test</span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Topology Type (for Link_T0_test.sh, ExitEVT.sh, run_all_test.sh) -->
                <div id="topologyTypeSection" style="margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #4CAF50; font-weight: bold; font-size: 14px;">
                        <span id="topologyTypeLabel">3. Topology Type</span>
                    </label>
                    <select id="topologyTypeSelect" class="topology-input" onchange="saveRunTestSelections();"
                        style="width: 100%; padding: 12px; font-size: 14px;">
                        <option value="">-- Select Topology Type --</option>
                    </select>
                </div>

                <!-- Topology File (for Link_T0_test.sh, ExitEVT.sh, run_all_test.sh) -->
                <div id="topologyFileSection" style="margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: #4CAF50; font-weight: bold; font-size: 14px;">
                        <span id="topologyFileLabel">4. Topology File Name list</span>
                    </label>
                    <select id="topologyFileSelect" class="topology-input" onchange="saveRunTestSelections();"
                        style="width: 100%; padding: 12px; font-size: 14px;">
                        <option value="">-- Select Topology File --</option>
                    </select>
                </div>

                <!-- Clean /opt/fboss Option -->
                <div
                    style="margin-bottom: 20px; padding: 15px; background: rgba(244, 67, 54, 0.1); border: 2px solid rgba(244, 67, 54, 0.3); border-radius: 8px;">
                    <label
                        style="display: flex; align-items: center; cursor: pointer; color: #F44336; font-weight: bold;">
                        <input type="checkbox" id="cleanFbossCheckbox" onchange="saveRunTestSelections();"
                            style="width: 20px; height: 20px; margin-right: 12px; cursor: pointer;">
                        <span style="font-size: 14px;">üóëÔ∏è Clean /opt/fboss directory before test (Force re-extraction
                            of binaries)</span>
                    </label>
                    <div style="margin-top: 8px; margin-left: 32px; font-size: 12px; color: #95a5a6;">
                        ‚ö†Ô∏è Warning: This will remove the existing /opt/fboss directory and re-extract all binaries from
                        the .zst file.
                    </div>
                </div>

                <!-- Start/Stop Test Buttons -->
                <div style="margin-bottom: 30px; text-align: center;">
                    <button id="startTestBtn" onclick="startTest()" class="apply-btn"
                        style="padding: 15px 50px; font-size: 16px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);">
                        ‚ñ∂Ô∏è Start Test
                    </button>
                    <button id="stopTestBtn" onclick="stopTest()" class="apply-btn"
                        style="display: none; padding: 15px 50px; font-size: 16px; background: linear-gradient(135deg, #F44336 0%, #d32f2f 100%); box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);">
                        ‚èπÔ∏è Stop Test
                    </button>
                    <button onclick="showCurlCommands()" class="apply-btn"
                        style="padding: 15px 40px; font-size: 16px; background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4); margin-left: 15px;">
                        üìù Show API CURL Commands
                    </button>
                </div>

                <!-- Save Test Procedure -->
                <div style="margin-bottom: 30px;">
                    <div class="section-header">
                        <h2>üíæ Save Current Test Procedure</h2>
                    </div>
                    <div
                        style="background: rgba(33, 150, 243, 0.1); padding: 20px; border-radius: 8px; border: 2px solid rgba(33, 150, 243, 0.3);">
                        <div style="margin-bottom: 15px; color: #95a5a6; font-size: 13px;">
                            Save the current test configuration for quick access later. The procedure will include:
                            script, bin file, test level, topology type, topology file, and clean option.
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="procedureNameInput"
                                placeholder="Enter procedure name (e.g., copper_test_t0)"
                                style="flex: 1; padding: 12px; background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; font-size: 14px;">
                            <button onclick="saveTestProcedure()" class="apply-btn"
                                style="min-width: 150px; background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);">
                                üíæ Save Procedure
                            </button>
                        </div>
                        <div id="saveProcedureStatus" style="margin-top: 10px; font-size: 12px;"></div>
                    </div>
                </div>

                <!-- REST API Display -->
                <div id="restApiSection" style="display: none; margin-top: 30px;">
                    <div class="section-header">
                        <h2>üìã REST API Commands (for Remote Testing)</h2>
                        <button onclick="copyRestApiCommands()" class="apply-btn"
                            style="min-width: 120px; background: #2196F3;">
                            üìã Copy
                        </button>
                    </div>
                    <div
                        style="background: #1a1a1a; padding: 20px; border-radius: 8px; margin-top: 10px; border: 2px solid rgba(76, 175, 80, 0.3);">
                        <pre id="restApiDisplay"
                            style="margin: 0; color: #4CAF50; font-family: 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CURL Commands Modal -->
    <div id="curlModal"
        style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7);">
        <div
            style="background-color: #2c3e50; margin: 5% auto; padding: 0; border-radius: 10px; width: 80%; max-width: 900px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
            <!-- Modal Header -->
            <div
                style="background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); padding: 20px; border-radius: 10px 10px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white; font-size: 22px;">üîß API CURL Commands</h2>
                <button onclick="closeCurlModal()"
                    style="background: none; border: none; color: white; font-size: 28px; cursor: pointer; padding: 0; width: 35px; height: 35px; line-height: 35px; text-align: center; border-radius: 50%; transition: background 0.3s;"
                    onmouseover="this.style.background='rgba(255,255,255,0.2)'"
                    onmouseout="this.style.background='none'">
                    &times;
                </button>
            </div>

            <!-- Modal Body -->
            <div style="padding: 25px; max-height: 70vh; overflow-y: auto;">
                <div
                    style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(33, 150, 243, 0.3); margin-bottom: 20px;">
                    <p style="margin: 0; color: #95a5a6; font-size: 14px; line-height: 1.6;">
                        üí° <strong>Usage:</strong> Copy and paste these commands to execute tests remotely via REST API.
                        The DUT IP address is automatically detected from your current connection.
                    </p>
                </div>

                <!-- CURL Command Display -->
                <div
                    style="background: #1a1a1a; padding: 20px; border-radius: 8px; border: 2px solid rgba(76, 175, 80, 0.3); position: relative;">
                    <button onclick="copyCurlCommand()"
                        style="position: absolute; top: 10px; right: 10px; padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; font-weight: bold; transition: background 0.3s;"
                        onmouseover="this.style.background='#1976D2'" onmouseout="this.style.background='#2196F3'">
                        üìã Copy
                    </button>
                    <pre id="curlCommandDisplay"
                        style="margin: 0; margin-top: 30px; color: #4CAF50; font-family: 'Courier New', monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word; line-height: 1.8;"></pre>
                </div>

                <div id="curlCopyStatus"
                    style="margin-top: 15px; text-align: center; font-size: 14px; font-weight: bold;"></div>
            </div>

            <!-- Modal Footer -->
            <div
                style="background: rgba(0,0,0,0.2); padding: 15px 25px; border-radius: 0 0 10px 10px; text-align: right;">
                <button onclick="closeCurlModal()"
                    style="padding: 10px 30px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; transition: background 0.3s;"
                    onmouseover="this.style.background='#7f8c8d'" onmouseout="this.style.background='#95a5a6'">
                    Close
                </button>
            </div>
        </div>
    </div>

    <script>
        let selectedPort = null;
        let connections = {};
        // Store per-connection colors keyed by sorted port pair (e.g. "eth1/1/1-eth1/2/1")
        let connectionColors = {};
        // A simple palette to pick distinct colors from
        const colorPalette = ['#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#9B5DE5', '#FF7AB6', '#00C2CB', '#FF8A00', '#7CFFB2', '#B28Dff'];
        let nextColorIndex = 0;

        let currentPlatform = 'MINIPACK3N';

        // Store absent ports (from fboss2_show_transceivers.txt - ports marked as Absent)
        let absentPorts = new Set();

        // Store present transceivers (from fboss2_show_transceivers.txt - ports that are Present)
        let presentTransceivers = new Set();

        // Tab switching function
        function switchTab(tabName) {
            // Save current tab to localStorage
            localStorage.setItem('activeTab', tabName);

            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            if (tabName === 'topology') {
                document.getElementById('topologyTab').classList.add('active');
                document.querySelectorAll('.tab-btn')[0].classList.add('active');
                // Stop auto-refresh when leaving transceiver tab
                stopTransceiverAutoRefresh();
                stopTestInfoAutoRefresh();
                // Refresh topology data
                loadAbsentPorts();
                loadPresentTransceivers();
            } else if (tabName === 'transceiver') {
                document.getElementById('transceiverTab').classList.add('active');
                document.querySelectorAll('.tab-btn')[1].classList.add('active');
                // Load transceiver data when switching to this tab
                loadTransceiverData();
                // Start auto-refresh
                startTransceiverAutoRefresh();
                stopTestInfoAutoRefresh();
                // Restore view preference after a short delay
                setTimeout(() => {
                    restoreTransceiverView();
                }, 200);
            } else if (tabName === 'testinfo') {
                document.getElementById('testinfoTab').classList.add('active');
                document.querySelectorAll('.tab-btn')[2].classList.add('active');
                // Load test info when switching to this tab
                loadTestInfo();
                // Start auto-refresh every 5 seconds
                startTestInfoAutoRefresh();
                stopTransceiverAutoRefresh();
            } else if (tabName === 'runtest') {
                document.getElementById('runtestTab').classList.add('active');
                document.querySelectorAll('.tab-btn')[3].classList.add('active');
                // Load run test data when switching to this tab
                loadTestScripts();
                loadBinFiles();
                loadTopologyTypes();
                loadTopologyFiles(currentPlatform);
                loadSavedProcedures(); // Load saved test procedures
                // Restore all cached selections (includes clean_fboss and test items)
                setTimeout(() => {
                    restoreRunTestSelections();
                }, 300); // Wait for dropdowns to populate
                // Stop auto-refresh
                stopTransceiverAutoRefresh();
                stopTestInfoAutoRefresh();
                // Start checking test status
                startTestStatusCheck();
            }
        }

        // Restore last active tab on page load
        window.addEventListener('DOMContentLoaded', function () {
            // Initialize sessionStorage with current platform
            sessionStorage.setItem('selectedPlatform', currentPlatform);
            console.log('[init] Platform initialized:', currentPlatform);

            const savedTab = localStorage.getItem('activeTab') || 'topology';
            console.log('[init] Restoring tab:', savedTab);
            switchTab(savedTab);

            // If transceiver tab is active, restore view preference
            if (savedTab === 'transceiver') {
                setTimeout(() => {
                    restoreTransceiverView();
                }, 300);
            }
        });

        let transceiverRefreshTimer = null;

        function startTransceiverAutoRefresh() {
            // Clear any existing timer
            stopTransceiverAutoRefresh();
            // Refresh every 30 seconds
            transceiverRefreshTimer = setInterval(() => {
                console.log('Auto-refreshing transceiver data...');
                loadTransceiverData();
            }, 30000);
        }

        function stopTransceiverAutoRefresh() {
            if (transceiverRefreshTimer) {
                clearInterval(transceiverRefreshTimer);
                transceiverRefreshTimer = null;
            }
        }

        // Load transceiver data from backend
        function loadTransceiverData() {
            console.log('[loadTransceiverData] Starting fetch...');
            fetch('/api/transceiver_info')
                .then(r => {
                    console.log('[loadTransceiverData] Response status:', r.status, r.ok);
                    return r.ok ? r.json() : null;
                })
                .then(data => {
                    console.log('[loadTransceiverData] Data received:', data);
                    if (data) {
                        updateTransceiverTable(data);
                    } else {
                        console.log('No transceiver data available');
                    }
                })
                .catch(err => {
                    console.error('Failed to load transceiver data:', err);
                    document.getElementById('transceiverTableBody').innerHTML =
                        '<tr><td colspan="13" style="text-align: center; padding: 40px; color: #F44336;">Failed to load, please try again later</td></tr>';
                });
        }

        // Store current transceiver data globally
        let currentTransceiverData = null;
        let currentTransceiverView = 'list'; // 'list' or 'portmap'

        // Switch between List and Port Map views
        function switchTransceiverView(viewType) {
            currentTransceiverView = viewType;

            // Save preference to localStorage
            localStorage.setItem('transceiverViewType', viewType);

            // Update button states
            document.querySelectorAll('.view-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Add active class to the clicked button
            const buttons = document.querySelectorAll('.view-type-btn');
            if (viewType === 'list') {
                buttons[0].classList.add('active');
            } else {
                buttons[1].classList.add('active');
            }

            // Toggle visibility
            if (viewType === 'list') {
                document.getElementById('listView').style.display = 'block';
                document.getElementById('portMapView').style.display = 'none';
            } else {
                document.getElementById('listView').style.display = 'none';
                document.getElementById('portMapView').style.display = 'block';
                // Render port map if we have data
                if (currentTransceiverData) {
                    renderPortMap(currentTransceiverData);
                }
            }
        }

        // Render Port Map view
        function renderPortMap(data) {
            const grid = document.getElementById('portMapGrid');

            if (!data.ports || data.ports.length === 0) {
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #95a5a6;">No Data</div>';
                return;
            }

            // Helper function to get vendor class for background color
            const getVendorClass = (v) => {
                if (!v) return 'vendor-unknown';
                const vl = v.toLowerCase();
                if (vl.includes('eoptolink')) return 'vendor-eoptolink';
                if (vl.includes('finisar')) return 'vendor-finisar';
                if (vl.includes('innolight')) return 'vendor-innolight';
                if (vl.includes('intel')) return 'vendor-intel';
                return 'vendor-unknown';
            };

            // Group ports by transceiver number and keep only one port per transceiver
            const portsByTransceiver = {};

            data.ports.forEach(port => {
                const match = (port.port || port.name || '').match(/eth1\/(\d+)\//);
                if (match) {
                    const transceiverNum = parseInt(match[1]);
                    if (!portsByTransceiver[transceiverNum]) {
                        portsByTransceiver[transceiverNum] = port;
                    }
                }
            });

            // Sort by transceiver number (1, 2, 3, 4, 5, 6...)
            // CSS Grid with grid-auto-flow: column will handle the layout automatically
            const sortedPorts = Object.entries(portsByTransceiver)
                .map(([num, port]) => ({ transceiverNum: parseInt(num), port }))
                .sort((a, b) => a.transceiverNum - b.transceiverNum)
                .map(item => item.port);

            // Build port map cards
            let html = '';
            sortedPorts.forEach((port, index) => {
                const statusClass = port.status === 'good' ? 'good' :
                    port.status === 'warning' ? 'warning' : 'critical';
                const tempStr = port.temperature != null ? `${port.temperature.toFixed(1)}¬∞C` : '';
                const vendor = port.vendor || 'Unknown';
                const vendorClass = getVendorClass(vendor);

                // Extract transceiver number from port name (eth1/X/Y)
                const match = (port.port || port.name || '').match(/eth1\/(\d+)\//);
                const transceiverNum = match ? match[1] : (index + 1);
                const displayName = `Transceiver ${transceiverNum}`;

                // Create tooltip with detailed info
                const tooltipParts = [];
                tooltipParts.push(`Port: ${port.port || port.name}`);
                tooltipParts.push(`Vendor: ${vendor}`);
                if (port.part_number) tooltipParts.push(`P/N: ${port.part_number}`);
                if (port.serial) tooltipParts.push(`S/N: ${port.serial}`);
                if (port.temperature != null) tooltipParts.push(`Temp: ${port.temperature.toFixed(1)}¬∞C`);
                if (port.tx_avg != null) tooltipParts.push(`TX: ${port.tx_avg.toFixed(2)} dBm`);
                if (port.rx_avg != null) tooltipParts.push(`RX: ${port.rx_avg.toFixed(2)} dBm`);
                if (port.warnings && port.warnings.length > 0) {
                    tooltipParts.push(`Issues: ${port.warnings.length}`);
                }

                const tooltip = tooltipParts.join('\\n');

                html += `
                    <div class="port-map-card ${statusClass} ${vendorClass}" title="${tooltip}">
                        <div class="status-dot"></div>
                        ${tempStr ? `<div class="temp-indicator">${tempStr}</div>` : ''}
                        <div class="port-number">${displayName}</div>
                        <div class="vendor-name">${vendor}</div>
                    </div>
                `;
            });

            grid.innerHTML = html;
        }

        // Update transceiver table with data
        function updateTransceiverTable(data) {
            console.log('[updateTransceiverTable] Starting update with data:', data);

            // Store data globally for port map view
            currentTransceiverData = data;

            const tbody = document.getElementById('transceiverTableBody');
            const total = data.ports ? data.ports.length : 0;
            console.log('[updateTransceiverTable] Total ports:', total);
            let good = 0, warning = 0, critical = 0;

            if (!data.ports || data.ports.length === 0) {
                console.log('[updateTransceiverTable] No ports, showing No Data message');
                tbody.innerHTML = '<tr><td colspan="13" style="text-align: center; padding: 40px; color: #95a5a6;">No Data</td></tr>';
                return;
            }

            // Helper function to get vendor badge class
            function getVendorBadgeClass(vendor) {
                if (!vendor) return 'vendor-unknown';
                const v = vendor.toLowerCase();
                if (v.includes('eoptolink')) return 'vendor-eoptolink';
                if (v.includes('finisar')) return 'vendor-finisar';
                if (v.includes('innolight')) return 'vendor-innolight';
                if (v.includes('intel')) return 'vendor-intel';
                return 'vendor-unknown';
            }

            // Sort ports by numeric value (eth1/X/Y)
            const sortedPorts = [...data.ports].sort((a, b) => {
                const matchA = (a.port || a.name || '').match(/eth1\/(\d+)\/(\d+)/);
                const matchB = (b.port || b.name || '').match(/eth1\/(\d+)\/(\d+)/);
                if (!matchA || !matchB) return 0;

                const portA = parseInt(matchA[1]);
                const portB = parseInt(matchB[1]);
                const laneA = parseInt(matchA[2]);
                const laneB = parseInt(matchB[2]);

                // Sort by port number first, then by lane
                if (portA !== portB) return portA - portB;
                return laneA - laneB;
            });

            // Build table rows
            let html = '';
            sortedPorts.forEach(port => {
                const statusClass = port.status === 'good' ? 'good' :
                    port.status === 'warning' ? 'warning' : 'critical';
                const statusText = port.status === 'good' ? 'Good' :
                    port.status === 'warning' ? 'Warning' : 'Critical';

                if (port.status === 'good') good++;
                else if (port.status === 'warning') warning++;
                else if (port.status === 'critical') critical++;

                const vendorBadgeClass = getVendorBadgeClass(port.vendor);

                html += `
                    <tr class="${statusClass}">
                        <td><strong>${port.port || port.name}</strong></td>
                        <td><span class="vendor-badge ${vendorBadgeClass}">${port.vendor || '-'}</span></td>
                        <td style="font-size: 11px; font-family: monospace;">${port.serial || '-'}</td>
                        <td style="font-size: 11px;">${port.part_number || '-'}</td>
                        <td style="text-align: center;"><span class="status-badge ${statusClass}">${statusText}</span></td>
                        <td style="text-align: right;">${port.temperature != null ? port.temperature.toFixed(1) : '-'}</td>
                        <td style="text-align: right;">${port.tx_avg != null ? port.tx_avg.toFixed(2) : '-'}</td>
                        <td style="text-align: right;">${port.rx_avg != null ? port.rx_avg.toFixed(2) : '-'}</td>
                        <td style="text-align: right;">${port.tx_range != null ? port.tx_range.toFixed(2) : '-'}</td>
                        <td style="text-align: right;">${port.rx_range != null ? port.rx_range.toFixed(2) : '-'}</td>
                        <td style="font-size: 11px;">${port.fw_app_version || '-'}</td>
                        <td style="font-size: 11px;">${port.fw_dsp_version || '-'}</td>
                        <td style="text-align: right;">${Array.isArray(port.issues) ? port.issues.length : (port.issues || 0)}</td>
                    </tr>
                `;
            });

            tbody.innerHTML = html;

            // Update summary cards
            document.getElementById('totalPorts').textContent = total;
            document.getElementById('goodPorts').textContent = good;
            document.getElementById('goodPercent').textContent = total > 0 ? `${Math.round(good / total * 100)}%` : '-';
            document.getElementById('warningPorts').textContent = warning;
            document.getElementById('warningPercent').textContent = total > 0 ? `${Math.round(warning / total * 100)}%` : '-';
            document.getElementById('criticalPorts').textContent = critical;
            document.getElementById('criticalPercent').textContent = total > 0 ? `${Math.round(critical / total * 100)}%` : '-';

            // Update issues summary
            if (data.summary) {
                document.getElementById('issuesSummary').innerHTML = data.summary;
            }

            // Add last update timestamp
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            document.getElementById('issuesSummary').innerHTML += `\n\n<div style="margin-top: 20px; color: #95a5a6; font-size: 12px;">Last updated: ${timeStr}</div>`;

            // Update port map view if it's currently visible
            if (currentTransceiverView === 'portmap') {
                renderPortMap(data);
            }
        }

        // Restore transceiver view preference on page load
        function restoreTransceiverView() {
            const savedView = localStorage.getItem('transceiverViewType');
            if (savedView && savedView === 'portmap') {
                // Delay to ensure DOM is ready
                setTimeout(() => {
                    switchTransceiverView('portmap');
                }, 100);
            }
        }

        // Table sorting functionality
        let sortColumn = -1;
        let sortAscending = true;

        function sortTransceiverTable(columnIndex) {
            const table = document.getElementById('transceiverTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            // Remove all sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Determine sort direction
            if (sortColumn === columnIndex) {
                sortAscending = !sortAscending;
            } else {
                sortAscending = true;
                sortColumn = columnIndex;
            }

            // Add sort indicator to current column
            const headers = table.querySelectorAll('th');
            if (sortAscending) {
                headers[columnIndex].classList.add('sort-asc');
            } else {
                headers[columnIndex].classList.add('sort-desc');
            }

            // Sort rows
            rows.sort((a, b) => {
                const cellA = a.cells[columnIndex];
                const cellB = b.cells[columnIndex];

                if (!cellA || !cellB) return 0;

                let valA = cellA.textContent.trim();
                let valB = cellB.textContent.trim();

                // Extract numeric values for port names (eth1/X/Y)
                if (columnIndex === 0) {
                    const matchA = valA.match(/eth1\/(\d+)\/(\d+)/);
                    const matchB = valB.match(/eth1\/(\d+)\/(\d+)/);
                    if (matchA && matchB) {
                        const portA = parseInt(matchA[1]) * 100 + parseInt(matchA[2]);
                        const portB = parseInt(matchB[1]) * 100 + parseInt(matchB[2]);
                        return sortAscending ? portA - portB : portB - portA;
                    }
                }

                // Handle numeric columns (temperature, TX/RX values, issues)
                if ([5, 6, 7, 8, 9, 12].includes(columnIndex)) {
                    const numA = parseFloat(valA) || 0;
                    const numB = parseFloat(valB) || 0;
                    return sortAscending ? numA - numB : numB - numA;
                }

                // Handle status column
                if (columnIndex === 4) {
                    const statusOrder = { 'Critical': 3, 'Warning': 2, 'Good': 1 };
                    const statusA = statusOrder[valA] || 0;
                    const statusB = statusOrder[valB] || 0;
                    return sortAscending ? statusA - statusB : statusB - statusA;
                }

                // Text comparison for other columns
                return sortAscending ?
                    valA.localeCompare(valB) :
                    valB.localeCompare(valA);
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        // Load absent ports from fboss2_show_transceivers.txt
        // If file doesn't exist, returns empty list (all ports treated as present)
        function loadAbsentPorts() {
            return fetch('/api/absent_ports')
                .then(r => r.ok ? r.json() : null)
                .then(data => {
                    if (data && data.absentPorts) {
                        absentPorts = new Set();

                        // For each absent port, add all possible lanes of that physical port
                        data.absentPorts.forEach(portName => {
                            // Extract port number (e.g., "eth1/41/1" -> 41)
                            const match = portName.match(/eth1\/(\d+)\//);
                            if (match) {
                                const portNum = match[1];
                                // Add all possible lanes for this port (/1, /2, /3, /4, /5, /6, /7, /8)
                                for (let lane = 1; lane <= 8; lane++) {
                                    absentPorts.add(`eth1/${portNum}/${lane}`);
                                }
                            } else {
                                // Fallback: just add the port as-is
                                absentPorts.add(portName);
                            }
                        });

                        console.log(`Loaded ${data.absentPorts.length} absent ports, expanded to ${absentPorts.size} lanes:`, Array.from(absentPorts).slice(0, 20));
                        applyAbsentPortStyles();
                    } else {
                        // No absent ports data means all ports are present
                        console.log('No absent ports data - all ports treated as present');
                        absentPorts = new Set();
                        applyAbsentPortStyles();
                    }
                })
                .catch(err => {
                    console.error('Failed to load absent ports:', err);
                    // On error, treat all ports as present
                    absentPorts = new Set();
                });
        }

        // Load present transceivers from fboss2_show_transceivers.txt
        function loadPresentTransceivers() {
            return fetch('/api/present_transceivers')
                .then(r => r.ok ? r.json() : null)
                .then(data => {
                    if (data && data.presentPorts) {
                        presentTransceivers = new Set();

                        // For each present port, add all possible lanes of that physical port
                        data.presentPorts.forEach(portName => {
                            // Extract port number (e.g., "eth1/41/1" -> 41)
                            const match = portName.match(/eth1\/(\d+)\//);
                            if (match) {
                                const portNum = match[1];
                                // Add all possible lanes for this port (/1, /2, /3, /4, /5, /6, /7, /8)
                                for (let lane = 1; lane <= 8; lane++) {
                                    presentTransceivers.add(`eth1/${portNum}/${lane}`);
                                }
                            } else {
                                // Fallback: just add the port as-is
                                presentTransceivers.add(portName);
                            }
                        });

                        console.log(`Loaded ${data.presentPorts.length} present transceivers, expanded to ${presentTransceivers.size} lanes:`, Array.from(presentTransceivers).slice(0, 20));
                    } else {
                        console.warn('No present transceivers data available, all ports will be shown');
                        presentTransceivers = new Set(); // Empty set means no filtering
                    }
                    // Apply styles after loading transceiver data
                    applyAbsentPortStyles();
                })
                .catch(err => {
                    console.error('Failed to load present transceivers:', err);
                    presentTransceivers = new Set(); // Empty set on error means no filtering
                    // Apply styles even on error to ensure ports are visible
                    applyAbsentPortStyles();
                });
        }

        // Apply styles to absent ports
        function applyAbsentPortStyles() {
            // Always apply absent port styles if we have absent port data (from fboss2_show_port.txt)
            document.querySelectorAll('.port-slot').forEach(slot => {
                const portName = slot.dataset.port;
                if (absentPorts.has(portName)) {
                    slot.classList.add('port-absent');
                    slot.style.pointerEvents = 'none';
                    slot.style.opacity = '0.3';
                    slot.style.filter = 'grayscale(80%)';
                    slot.title = `${portName} - Transceiver Absent`;
                } else {
                    slot.classList.remove('port-absent');
                    slot.style.pointerEvents = '';
                    slot.style.opacity = '';
                    slot.style.filter = '';
                }
            });

            // Disable container actions for containers with all ports absent
            document.querySelectorAll('.port-container').forEach(container => {
                const slots = container.querySelectorAll('.port-slot:not(.hidden)');
                const allAbsent = Array.from(slots).every(slot => absentPorts.has(slot.dataset.port));

                if (allAbsent) {
                    container.style.pointerEvents = 'none';
                    container.style.opacity = '0.3';
                    container.style.filter = 'grayscale(80%)';
                    const innerFrame = container.querySelector('.inner-frame');
                    if (innerFrame) {
                        innerFrame.style.cursor = 'not-allowed';
                    }
                } else {
                    // Reset styles if not all absent
                    container.style.pointerEvents = '';
                    container.style.opacity = '';
                    container.style.filter = '';
                    const innerFrame = container.querySelector('.inner-frame');
                    if (innerFrame) {
                        innerFrame.style.cursor = '';
                    }
                }
            });
        }

        function getNextColor() {
            const c = colorPalette[nextColorIndex % colorPalette.length];
            nextColorIndex++;
            return c;
        }

        const platformConfigs = {
            'MINIPACK3N': { ports: 65, defaultProfile: 39 },
            'MINIPACK3BA': { ports: 65, defaultProfile: 39 },
            'WEDGE800BACT': { ports: 33, defaultProfile: 39 },
            'WEDGE800CACT': { ports: 33, defaultProfile: 39 }
        };

        const profileConfigs = {
            // Copper
            50: { speed: '800G', ports: 1, type: 'Copper', color: '#e6e6ff' },
            45: { speed: '400G', ports: 2, type: 'Copper', color: '#ccccff' },
            35: { speed: '400G', ports: 1, type: 'Copper', color: '#b3b3ff' },
            24: { speed: '200G', ports: 2, type: 'Copper', color: '#adadff' },
            54: { speed: '200G', ports: 2, type: 'Copper', color: '#9999ff' },
            55: { speed: '100G', ports: 2, type: 'Copper', color: '#8080ff' },
            // Optical (use hex so we can vary shades)
            39: { speed: '800G', ports: 1, type: 'Optical', color: '#4CAF50' },
            38: { speed: '400G', ports: 2, type: 'Optical', color: '#90EE90' },
            30: { speed: '25G', ports: 2, type: 'Optical', color: '#B39DDB' },
            25: { speed: '200G', ports: 2, type: 'Optical', color: '#1565C0' },
            23: { speed: '100G', ports: 2, type: 'Optical', color: '#64B5F6' },
            47: { speed: '100G', ports: 1, type: 'Optical', color: '#64B5F6' },
            48: { speed: '50G', ports: 2, type: 'Optical', color: '#B3E5FC', layout: '1,3' }
        };

        const profileCycles = {
            1: [50, 35, 39, 47], // 1 port profiles
            2: [45, 24, 54, 55, 38, 25, 23]  // 2 port profiles
        };

        function switchPlatform(platform, ev) {
            currentPlatform = platform;

            // Store platform in sessionStorage for dashboard
            sessionStorage.setItem('selectedPlatform', platform);
            console.log('[Platform] Set to:', platform);

            // set active button (works whether called from event or programmatically)
            document.querySelectorAll('.platform-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            try {
                if (ev && ev.target) ev.target.classList.add('active');
                else {
                    const btn = Array.from(document.querySelectorAll('.platform-btn')).find(b => b.textContent.trim() === platform);
                    if (btn) btn.classList.add('active');
                }
            } catch (e) { }

            // Update status to show save location
            const platformFileMap = {
                'MINIPACK3BA': 'montblanc.materialized_JSON',
                'MINIPACK3N': 'minipack3n.materialized_JSON',
                'WEDGE800BACT': 'wedge800bact.materialized_JSON',
                'WEDGE800CACT': 'wedge800bact.materialized_JSON'
            };
            const targetFile = platformFileMap[platform] || 'topology.materialized_JSON';
            updateStatus(`Platform: ${platform} | Save target: Topology/${platform}/${targetFile}`);

            clearAllConnections();
            generatePorts();

            // Reload absent ports and present transceivers when switching platform
            loadAbsentPorts();
            loadPresentTransceivers();

            // Refresh Run Test tab topology file list when platform changes
            loadTopologyFiles(platform);

            // attempt to load topology for the newly selected platform; prefer detected preferred file when present
            setTimeout(() => {
                fetch('/api/detect_initial')
                    .then(r => r.ok ? r.json() : null)
                    .then(j => {
                        if (j && j.platform && j.preferred_file && j.platform === platform) {
                            loadTopologyFile(platform, j.preferred_file);
                        } else {
                            loadTopology();
                        }
                    })
                    .catch(() => { loadTopology(); });
            }, 120);
        }

        function generatePorts() {
            const config = platformConfigs[currentPlatform];
            const portGrid = document.getElementById('portGrid');
            portGrid.innerHTML = '';

            // Set layout class based on platform
            if (currentPlatform === 'MINIPACK3N' || currentPlatform === 'MINIPACK3BA') {
                portGrid.className = 'port-grid minipack-layout';
            } else {
                portGrid.className = 'port-grid wedge-layout';
            }

            for (let i = 1; i <= config.ports; i++) {
                const profile = config.defaultProfile;
                const profileClass = `profile-${profile}`;
                const profileConfig = profileConfigs[profile];

                const portContainer = document.createElement('div');
                portContainer.className = 'port-container';
                portContainer.dataset.mode = profileConfig.speed;
                portContainer.dataset.profile = profile;
                portContainer.onclick = (e) => switchMode(e, portContainer);

                // For service port 65 on MINIPACK3N, use /1 and /2 instead of /1, /3, /5, /7
                const isServicePort = (currentPlatform === 'MINIPACK3N' && i === 65);
                const subPorts = isServicePort
                    ? ['1', '2']
                    : ['1', '3', '5', '7'];

                // Update port visibility logic to support custom layouts
                const ports = subPorts.map((subPort, idx) => `
                    <div class="port-slot ${idx > 0 ? 'hidden' : ''}" data-port="eth1/${i}/${subPort}" onclick="selectPort(event, this)" onmouseenter="portHover(event,this)" onmouseleave="portLeave(event,this)">
                        <span class="port-name">eth1/${i}/${subPort}</span>
                        <div class="port-info">
                            <span class="speed-label">${profileConfig.speed}</span>
                            <span class="profile-label">P${profile}</span>
                        </div>
                    </div>
                `).join('');

                portContainer.innerHTML = `
                    <div class="inner-frame ${profileClass}" onclick="switchProfile(event, this)">
                        ${ports}
                    </div>
                `;

                // Set initial visibility based on config
                // This handles the initial render correctly before any switching happens
                const portSlots = portContainer.querySelectorAll('.port-slot');
                if (profileConfig.layout === '1,3' && portSlots.length >= 2) {
                    // Specifically for layout 1,3 (e.g. Profile 48)
                    if (portSlots[0]) portSlots[0].classList.remove('hidden'); // /1
                    if (portSlots[1]) portSlots[1].classList.remove('hidden'); // /3 (mapped from index 1 in subPorts=['1','3','5','7'])
                    if (portSlots[2]) portSlots[2].classList.add('hidden');
                    if (portSlots[3]) portSlots[3].classList.add('hidden');
                } else if (profileConfig.ports === 1) {
                    if (portSlots[0]) portSlots[0].classList.remove('hidden');
                    for (let k = 1; k < portSlots.length; k++) portSlots[k].classList.add('hidden');
                } else if (profileConfig.ports === 2) {
                    // Standard 2-port layout (/1 and /5 usually)
                    if (portSlots[0]) portSlots[0].classList.remove('hidden');
                    // If it's a service port with only 2 slots, show both. 
                    // Otherwise (normal port with 4 slots), show index 0 and 2 (corresponding to /1 and /5)
                    if (portSlots.length === 2) {
                        if (portSlots[1]) portSlots[1].classList.remove('hidden');
                    } else {
                        if (portSlots[1]) portSlots[1].classList.add('hidden');
                        if (portSlots[2]) portSlots[2].classList.remove('hidden');
                        if (portSlots[3]) portSlots[3].classList.add('hidden');
                    }
                } else if (profileConfig.ports === 4) {
                    // 4-port layout (/1, /3, /5, /7)
                    for (let k = 0; k < portSlots.length; k++) {
                        if (portSlots[k]) portSlots[k].classList.remove('hidden');
                    }
                }

                portGrid.appendChild(portContainer);
            }

            // Apply absent port styles after generating ports
            applyAbsentPortStyles();
        }

        function switchMode(event, container) {
            event.stopPropagation();

            // Check if any visible ports are absent
            const visibleSlots = container.querySelectorAll('.port-slot:not(.hidden)');
            const hasAbsentPort = Array.from(visibleSlots).some(slot => absentPorts.has(slot.dataset.port));

            if (hasAbsentPort) {
                const absentList = Array.from(visibleSlots)
                    .filter(slot => absentPorts.has(slot.dataset.port))
                    .map(slot => slot.dataset.port)
                    .join(', ');
                updateStatus(`Cannot switch mode: Port ${absentList} Transceiver Absent`);
                return;
            }

            // when changing profile/port type, disconnect any existing connections on this container
            try {
                const removed = disconnectContainerConnections(container);
                if (removed > 0) updateStatus(`Automatically disconnected ${removed} connection(s) due to profile change`);
            } catch (e) { }

            const currentProfile = parseInt(container.dataset.profile);
            const profileConfig = profileConfigs[currentProfile];
            const currentPortCount = profileConfig.ports;

            // Get the cycle array based on current port count
            const cycle = profileCycles[currentPortCount];
            const currentIndex = cycle.indexOf(currentProfile);
            const nextIndex = (currentIndex + 1) % cycle.length;
            const nextProfile = cycle[nextIndex];
            const nextConfig = profileConfigs[nextProfile];

            // Update container
            container.dataset.profile = nextProfile;
            container.dataset.mode = nextConfig.speed;

            // Update all port slots with new speed and profile
            const innerFrame = container.querySelector('.inner-frame');
            const portSlots = container.querySelectorAll('.port-slot');
            portSlots.forEach(slot => {
                const speedLabel = slot.querySelector('.speed-label');
                const profileLabel = slot.querySelector('.profile-label');
                if (speedLabel) speedLabel.textContent = nextConfig.speed;
                if (profileLabel) profileLabel.textContent = `P${nextProfile}`;
            });

            // Update frame color
            innerFrame.className = `inner-frame profile-${nextProfile}`;

            // Update port visibility
            // Update port visibility
            const ports = container.querySelectorAll('.port-slot');

            if (nextConfig.layout === '1,3') {
                if (ports[0]) ports[0].classList.remove('hidden');
                if (ports[1]) ports[1].classList.remove('hidden'); // index 1 is subPort '3' in standard array
                if (ports[2]) ports[2].classList.add('hidden');
                if (ports[3]) ports[3].classList.add('hidden');
            } else if (nextConfig.ports === 1) {
                // Show only first port
                ports[0].classList.remove('hidden');
                for (let i = 1; i < ports.length; i++) {
                    ports[i].classList.add('hidden');
                }
            } else if (nextConfig.ports === 2) {
                // Show first two ports (handles both /1,/5 and /1,/2 patterns)
                ports[0].classList.remove('hidden');
                if (ports.length === 2) {
                    // Service port with only 2 sub-ports
                    ports[1].classList.remove('hidden');
                } else {
                    // Regular port with /1, /3, /5, /7
                    ports[1].classList.add('hidden');
                    if (ports[2]) ports[2].classList.remove('hidden');
                    if (ports[3]) ports[3].classList.add('hidden');
                }
            } else if (nextConfig.ports === 4) {
                // 4-port layout (/1, /3, /5, /7)
                for (let i = 0; i < ports.length; i++) {
                    if (ports[i]) ports[i].classList.remove('hidden');
                }
            }

            drawAllConnections();
        }

        function switchProfile(event, innerFrame) {
            event.stopPropagation();

            const container = innerFrame.closest('.port-container');

            // Check if any visible ports are absent
            const visibleSlots = container.querySelectorAll('.port-slot:not(.hidden)');
            const hasAbsentPort = Array.from(visibleSlots).some(slot => absentPorts.has(slot.dataset.port));

            if (hasAbsentPort) {
                const absentList = Array.from(visibleSlots)
                    .filter(slot => absentPorts.has(slot.dataset.port))
                    .map(slot => slot.dataset.port)
                    .join(', ');
                updateStatus(`Cannot switch profile: Port ${absentList} Transceiver Absent`);
                return;
            }

            // disconnect existing connections when toggling profile via left-click
            try {
                const removed = disconnectContainerConnections(container);
                if (removed > 0) updateStatus(`Automatically disconnected ${removed} connection(s) due to profile change`);
            } catch (e) { }
            const currentProfile = parseInt(container.dataset.profile);
            const profileConfig = profileConfigs[currentProfile];
            const currentPortCount = profileConfig.ports;

            // Determine which cycle to use (1-port or 2-port)
            let nextPortCount;
            if (currentPortCount === 1) {
                nextPortCount = 2; // Switch to 2-port cycle
            } else {
                nextPortCount = 1; // Switch to 1-port cycle
            }

            // Get first profile from the new cycle
            const nextProfile = profileCycles[nextPortCount][0];
            const nextConfig = profileConfigs[nextProfile];

            // Update container
            container.dataset.profile = nextProfile;
            container.dataset.mode = nextConfig.speed;

            // Update all port slots with new speed and profile
            const portSlots = container.querySelectorAll('.port-slot');
            portSlots.forEach(slot => {
                const speedLabel = slot.querySelector('.speed-label');
                const profileLabel = slot.querySelector('.profile-label');
                if (speedLabel) speedLabel.textContent = nextConfig.speed;
                if (profileLabel) profileLabel.textContent = `P${nextProfile}`;
            });

            // Update frame color
            innerFrame.className = `inner-frame profile-${nextProfile}`;

            // Update port visibility
            // Update port visibility
            const ports = container.querySelectorAll('.port-slot');

            if (nextConfig.layout === '1,3') {
                if (ports[0]) ports[0].classList.remove('hidden');
                if (ports[1]) ports[1].classList.remove('hidden');
                if (ports[2]) ports[2].classList.add('hidden');
                if (ports[3]) ports[3].classList.add('hidden');
            } else if (nextConfig.ports === 1) {
                // Show only first port
                ports[0].classList.remove('hidden');
                for (let i = 1; i < ports.length; i++) {
                    ports[i].classList.add('hidden');
                }
            } else if (nextConfig.ports === 2) {
                // Show first two ports (handles both /1,/5 and /1,/2 patterns)
                ports[0].classList.remove('hidden');
                if (ports.length === 2) {
                    // Service port with only 2 sub-ports
                    ports[1].classList.remove('hidden');
                } else {
                    // Regular port with /1, /3, /5, /7
                    ports[1].classList.add('hidden');
                    if (ports[2]) ports[2].classList.remove('hidden');
                    if (ports[3]) ports[3].classList.add('hidden');
                }
            } else if (nextConfig.ports === 4) {
                // 4-port layout (/1, /3, /5, /7)
                for (let i = 0; i < ports.length; i++) {
                    if (ports[i]) ports[i].classList.remove('hidden');
                }
            }

            drawAllConnections();
        }

        function selectPort(event, portSlot) {
            event.stopPropagation();

            const portId = portSlot.dataset.port;

            // Always check if port is absent (from fboss2_show_port.txt)
            if (absentPorts.has(portId)) {
                updateStatus(`Cannot operate: ${portId} - Transceiver Absent`);
                return;
            }

            if (connections[portId]) {
                const connectedPortId = connections[portId];
                const connectedPortSlot = document.querySelector(`[data-port="${connectedPortId}"]`);

                // remove stored color for this connection
                const key = [portId, connectedPortId].sort().join('-');
                const assigned = connectionColors[key];
                delete connectionColors[key];

                delete connections[portId];
                delete connections[connectedPortId];

                portSlot.classList.remove('connected');
                if (connectedPortSlot) {
                    connectedPortSlot.classList.remove('connected');
                }

                // clear applied persistent styles
                if (assigned) {
                    clearConnColorFromPort(portId);
                    clearConnColorFromPort(connectedPortId);
                }

                updateStatus(`Disconnected: ${portId} ‚Üî ${connectedPortId}`);
                drawAllConnections();
                return;
            }

            if (!selectedPort) {
                selectedPort = portSlot;
                portSlot.classList.add('selected');
                updateStatus(`Selected ${portId}, please select a port to connect`);
            } else {
                if (selectedPort === portSlot) {
                    selectedPort.classList.remove('selected');
                    selectedPort = null;
                    updateStatus('Selection cancelled');
                } else {
                    const firstPortId = selectedPort.dataset.port;
                    const secondPortId = portId;
                    // Validate profile IDs: only allow connections when both ports belong to the same profile
                    try {
                        const firstContainer = selectedPort.closest('.port-container');
                        const secondContainer = portSlot.closest('.port-container');
                        const firstProfile = firstContainer ? firstContainer.dataset.profile : null;
                        const secondProfile = secondContainer ? secondContainer.dataset.profile : null;
                        if (firstProfile && secondProfile && firstProfile !== secondProfile) {
                            updateStatus(`Cannot create connection: profiles do not match (P${firstProfile} ‚â† P${secondProfile})`);
                            // clear selection so user can choose a different port
                            selectedPort.classList.remove('selected');
                            selectedPort = null;
                            return;
                        }
                    } catch (e) { /* ignore and proceed if error */ }

                    connections[firstPortId] = secondPortId;
                    connections[secondPortId] = firstPortId;

                    // assign a unique color for this connection
                    const key = [firstPortId, secondPortId].sort().join('-');
                    if (!connectionColors[key]) connectionColors[key] = getNextColor();
                    const color = connectionColors[key];

                    selectedPort.classList.remove('selected');
                    selectedPort.classList.add('connected');
                    portSlot.classList.add('connected');

                    // apply persistent color to both port name boxes
                    applyConnColorToPort(firstPortId, color);
                    applyConnColorToPort(secondPortId, color);

                    updateStatus(`Connection created: ${firstPortId} ‚Üî ${secondPortId}`);
                    selectedPort = null;

                    drawAllConnections();
                }
            }
        }

        function drawAllConnections() {
            const svg = document.getElementById('connectionSvg');
            if (!svg) {
                console.error('ERROR: connectionSvg element not found!');
                return;
            }
            svg.innerHTML = '';

            console.log('üîµ drawAllConnections called');
            console.log('   Total connections:', Object.keys(connections).length);
            console.log('   Connections object:', connections);

            const drawn = new Set();
            // Collect visible connections and their coordinates first
            const items = [];
            const loopbacks = []; // Store loopback connections separately

            for (const [port1, port2] of Object.entries(connections)) {
                const key = [port1, port2].sort().join('-');
                if (drawn.has(key)) continue;
                drawn.add(key);

                const elem1 = document.querySelector(`[data-port="${port1}"]`);
                const elem2 = document.querySelector(`[data-port="${port2}"]`);
                if (!elem1 || !elem2) continue;
                if (elem1.classList.contains('hidden') || elem2.classList.contains('hidden')) continue;

                // Skip connections if either port is absent (transceiver not present)
                if (absentPorts.has(port1) || absentPorts.has(port2)) continue;

                const rect1 = elem1.getBoundingClientRect();
                const rect2 = elem2.getBoundingClientRect();
                const container = document.getElementById('mainContainer').getBoundingClientRect();

                const x1 = rect1.left + rect1.width / 2 - container.left;
                const y1 = rect1.top + rect1.height / 2 - container.top;
                const x2 = rect2.left + rect2.width / 2 - container.left;
                const y2 = rect2.top + rect2.height / 2 - container.top;

                // Check if this is a loopback connection (port connected to itself)
                if (port1 === port2) {
                    loopbacks.push({ port: port1, elem: elem1, x: x1, y: y1, key });
                } else {
                    items.push({ port1, port2, elem1, elem2, x1, y1, x2, y2, key });
                }
            }

            // Draw loopback circles first
            for (const lb of loopbacks) {
                const { port, elem, x, y, key } = lb;
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                const radius = 18; // Circle radius for loopback

                // Position circle to the right of the port
                circle.setAttribute('cx', x + 25);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', radius);
                circle.setAttribute('class', 'connection-line loopback-circle');
                circle.setAttribute('data-conn', key);
                circle.setAttribute('fill', 'none');

                // Get color for this loopback
                try {
                    const srcContainer = elem.closest('.port-container');
                    const profile = srcContainer ? srcContainer.dataset.profile : null;
                    let color = '#FFD700';

                    if (elem.classList.contains('link-error')) {
                        color = '#F44336';
                    } else {
                        const assigned = connectionColors[key];
                        if (assigned) {
                            color = assigned;
                        } else if (profile && profileConfigs[profile] && profileConfigs[profile].color) {
                            color = profileConfigs[profile].color;
                        }
                    }

                    circle.style.stroke = color;
                    circle.style.filter = `drop-shadow(0 0 6px ${color})`;
                } catch (e) { }

                svg.appendChild(circle);
            }

            // Group by approximate column (vertical) or row (horizontal) to detect overlaps
            const groups = new Map();
            for (const it of items) {
                const dx = Math.abs(it.x2 - it.x1);
                const dy = Math.abs(it.y2 - it.y1);

                let groupKey;
                if (dx < 30) {
                    // vertical group, round to nearest 20px to bucket nearby columns
                    const col = Math.round((it.x1 + it.x2) / 2 / 20) * 20;
                    groupKey = `col-${col}`;
                } else if (dy < 20) {
                    // horizontal group, round to nearest 20px to bucket nearby rows
                    const row = Math.round((it.y1 + it.y2) / 2 / 20) * 20;
                    groupKey = `row-${row}`;
                } else {
                    groupKey = `free-${it.key}`;
                }

                if (!groups.has(groupKey)) groups.set(groupKey, []);
                groups.get(groupKey).push(it);
            }

            // Draw groups ‚Äî if group has multiple items and is 'col' or 'row', offset curves
            for (const [gk, arr] of groups.entries()) {
                const n = arr.length;
                for (let idx = 0; idx < n; idx++) {
                    const it = arr[idx];
                    const { port1, port2, elem1, elem2, x1, y1, x2, y2, key } = it;

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let path = '';

                    if (gk.startsWith('col-') && n > 1) {
                        // vertical group with multiple connections: symmetric horizontal curve to avoid overlap
                        const midY = (y1 + y2) / 2;
                        const midX = (x1 + x2) / 2;
                        const spacing = 14; // px between parallel curves
                        const offsetIndex = idx - (n - 1) / 2; // center them
                        const offset = offsetIndex * spacing;
                        // use symmetric control X around midX so all curves have consistent shape
                        const cX = midX + offset;
                        path = `M ${x1} ${y1} C ${cX} ${midY}, ${cX} ${midY}, ${x2} ${y2}`;
                    } else if (gk.startsWith('row-') && n > 1) {
                        // horizontal group with multiple connections: symmetric vertical curve to avoid overlap
                        const midX = (x1 + x2) / 2;
                        const midY = (y1 + y2) / 2;
                        const spacing = 14;
                        const offsetIndex = idx - (n - 1) / 2;
                        const offset = offsetIndex * spacing;
                        // use symmetric control Y around midY so curves on top and bottom match
                        const cY = midY + offset;
                        path = `M ${x1} ${y1} C ${midX} ${cY}, ${midX} ${cY}, ${x2} ${y2}`;
                    } else {
                        // free or single ‚Äî keep previous logic: straight if same suffix or near-vertical, else curved
                        const suffix1 = port1.split('/')[2];
                        const suffix2 = port2.split('/')[2];
                        const sameSuffix = suffix1 === suffix2;
                        const dx = Math.abs(x2 - x1);
                        const isVertical = dx < 30;

                        if (sameSuffix || isVertical) {
                            if (isVertical) {
                                const offset = (suffix1 === '5') ? 15 : (suffix1 === '3' ? 7 : -15);
                                path = `M ${x1 + offset} ${y1} L ${x2 + offset} ${y2}`;
                            } else {
                                path = `M ${x1} ${y1} L ${x2} ${y2}`;
                            }
                        } else {
                            const midX = (x1 + x2) / 2;
                            const curve = Math.min(Math.abs(x2 - x1) * 0.3, 50);
                            path = `M ${x1} ${y1} Q ${midX} ${y1 - curve}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;
                        }
                    }

                    line.setAttribute('d', path);
                    line.setAttribute('class', 'connection-line');
                    // tag the path with the connection key so we can find it on hover
                    try {
                        const k = [port1, port2].sort().join('-');
                        line.setAttribute('data-conn', k);
                    } catch (e) { }

                    // color
                    try {
                        const k = [port1, port2].sort().join('-');
                        // If either endpoint has mismatch error, force red
                        const p1Err = elem1.classList.contains('link-error');
                        const p2Err = elem2.classList.contains('link-error');
                        if (p1Err || p2Err) {
                            const red = '#F44336';
                            line.style.stroke = red;
                            line.style.filter = `drop-shadow(0 0 6px ${red})`;
                        } else {
                            const assigned = connectionColors[k];
                            if (assigned) {
                                line.style.stroke = assigned;
                                line.style.filter = `drop-shadow(0 0 6px ${assigned})`;
                            } else {
                                const srcContainer = elem1.closest('.port-container');
                                const profile = srcContainer ? srcContainer.dataset.profile : null;
                                const color = (profile && profileConfigs[profile] && profileConfigs[profile].color) ? profileConfigs[profile].color : '#FFD700';
                                line.style.stroke = color;
                                line.style.filter = `drop-shadow(0 0 4px ${color})`;
                            }
                        }
                    } catch (e) { }

                    svg.appendChild(line);
                }
            }

            console.log('‚úÖ Drew', items.length, 'connection lines and', loopbacks.length, 'loopback circles');
            console.log('   Total paths in SVG:', svg.querySelectorAll('path, circle').length);

            // draw group boxes (upstream/downstream) for wedge platforms
            drawGroupBoxes();
        }

        // Convert hex color to rgba string with given alpha
        function hexToRgba(hex, alpha = 0.18) {
            try {
                const h = hex.replace('#', '');
                const bigint = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            } catch (e) {
                return hex;
            }
        }

        // Helpers to vary a hex color deterministically by a small amount based on seed
        function hexToRgb(hex) {
            const h = hex.replace('#', '');
            const full = h.length === 3 ? h.split('').map(c => c + c).join('') : h;
            const bigint = parseInt(full, 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }

        function rgbToHex(r, g, b) {
            const toHex = (v) => ('0' + Math.max(0, Math.min(255, Math.round(v))).toString(16)).slice(-2);
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function varyColor(hex, seed) {
            try {
                const [r, g, b] = hexToRgb(hex);
                const s = Math.abs(seed) % 40; // 0..39
                const factor = 0.78 + (s / 200); // 0.78 .. 0.975 small variation
                const nr = Math.min(255, r * factor + (s % 7));
                const ng = Math.min(255, g * factor + (s % 11));
                const nb = Math.min(255, b * factor + (s % 13));
                return rgbToHex(nr, ng, nb);
            } catch (e) {
                return hex;
            }
        }

        function applyConnColorToPort(portId, color) {
            try {
                const slot = document.querySelector(`[data-port="${portId}"]`);
                if (!slot) return;
                // set border and subtle background tint matching connection
                slot.style.borderColor = color;
                slot.style.boxShadow = `0 0 10px ${color}`;
                // apply a faint background using rgba
                slot.style.background = hexToRgba(color, 0.12);
                // also color the parent inner-frame border
                const inner = slot.closest('.inner-frame');
                if (inner) inner.style.borderColor = color;
            } catch (e) { }
        }

        function clearConnColorFromPort(portId) {
            try {
                const slot = document.querySelector(`[data-port="${portId}"]`);
                if (!slot) return;
                slot.style.borderColor = '';
                slot.style.boxShadow = '';
                slot.style.background = '';
                const inner = slot.closest('.inner-frame');
                if (inner) inner.style.borderColor = '';
            } catch (e) { }
        }

        // Disconnect any connections for all ports inside a given port-container
        function disconnectContainerConnections(container) {
            if (!container) return 0;
            const slots = Array.from(container.querySelectorAll('.port-slot'));
            let removed = 0;
            for (const s of slots) {
                const pid = s.dataset.port;
                if (!pid) continue;
                const peer = connections[pid];
                if (!peer) continue;

                // delete bi-directional mapping
                try {
                    delete connections[pid];
                    delete connections[peer];
                } catch (e) { }

                // remove connection color entry
                try {
                    const k = [pid, peer].sort().join('-');
                    if (connectionColors[k]) delete connectionColors[k];
                } catch (e) { }

                // clear visuals
                try {
                    s.classList.remove('connected', 'selected', 'glowing');
                    clearConnColorFromPort(pid);
                    const peerSlot = document.querySelector(`[data-port="${peer}"]`);
                    if (peerSlot) {
                        peerSlot.classList.remove('connected', 'selected', 'glowing');
                        clearConnColorFromPort(peer);
                    }
                } catch (e) { }

                // if this was the selectedPort, clear it
                try {
                    if (selectedPort && selectedPort.dataset && selectedPort.dataset.port === pid) {
                        selectedPort.classList.remove('selected');
                        selectedPort = null;
                    }
                } catch (e) { }

                removed++;
            }
            if (removed > 0) {
                drawAllConnections();
            }
            return removed;
        }

        async function quickConnect() {
            clearAllConnections();

            // Reload both absent ports and present transceivers
            updateStatus('Loading port status...');
            await Promise.all([
                loadAbsentPorts(),
                loadPresentTransceivers()
            ]);
            console.log(`Quick Connect: Loaded ${absentPorts.size} absent ports and ${presentTransceivers.size} present transceivers`);

            const config = platformConfigs[currentPlatform];
            const totalPorts = config.ports;

            // Get profile and port count from first port
            const firstPortContainer = document.querySelector('.port-container');
            if (!firstPortContainer) return;

            const firstProfile = parseInt(firstPortContainer.dataset.profile);
            const firstProfileConfig = profileConfigs[firstProfile];
            const portCount = firstProfileConfig.ports;

            // Determine service port configuration based on platform
            let servicePortNum, serviceProfile, serviceSpeed;
            if (currentPlatform === 'MINIPACK3BA') {
                servicePortNum = 65;
                serviceProfile = 23;
                serviceSpeed = '100G';
            } else if (currentPlatform === 'MINIPACK3N') {
                servicePortNum = 65;
                serviceProfile = 30;
                serviceSpeed = '25G';
            } else if (currentPlatform === 'WEDGE800BACT' || currentPlatform === 'WEDGE800CACT') {
                servicePortNum = 33;
                serviceProfile = 23;
                serviceSpeed = '100G';
            }

            // Helper function to check if a port can be connected
            const canConnect = (portId) => {
                // Always skip absent ports (from fboss2_show_port.txt)
                if (absentPorts.has(portId)) {
                    return false;
                }

                // If we have present transceivers data (from fboss2_show_transceivers.txt),
                // only connect ports that are present in that list
                if (presentTransceivers.size > 0 && !presentTransceivers.has(portId)) {
                    return false;
                }

                return true;
            };

            // Apply same profile to all ports first
            document.querySelectorAll('.port-container').forEach((container, index) => {
                const portNum = index + 1;

                // Check if this is the service port
                const isServicePort = (portNum === servicePortNum);

                // Use service port profile for service port, otherwise use first profile
                const targetProfile = isServicePort ? serviceProfile : firstProfile;
                const targetConfig = profileConfigs[targetProfile];
                const targetPortCount = targetConfig.ports;

                // Update profile
                container.dataset.profile = targetProfile;
                container.dataset.mode = targetConfig.speed;

                const innerFrame = container.querySelector('.inner-frame');
                if (innerFrame) {
                    innerFrame.className = `inner-frame profile-${targetProfile}`;
                }

                // Update all speed and profile labels in this container
                const speedLabels = container.querySelectorAll('.speed-label');
                speedLabels.forEach(label => label.textContent = targetConfig.speed);

                const profileLabels = container.querySelectorAll('.profile-label');
                profileLabels.forEach(label => label.textContent = `P${targetProfile}`);

                // Update port visibility
                const ports = container.querySelectorAll('.port-slot');
                if (targetPortCount === 1) {
                    if (ports[0]) ports[0].classList.remove('hidden');
                    if (ports[1]) ports[1].classList.add('hidden');
                    if (ports[2]) ports[2].classList.add('hidden');
                    if (ports[3]) ports[3].classList.add('hidden');
                } else if (targetPortCount === 2) {
                    if (ports[0]) ports[0].classList.remove('hidden');
                    if (ports[1]) ports[1].classList.add('hidden');
                    if (ports[2]) ports[2].classList.remove('hidden');
                    if (ports[3]) ports[3].classList.add('hidden');
                }
            });

            // Track skipped ports for reporting
            let skippedCount = 0;

            // Create connections based on port count
            // Always connect service port to itself first (if present)
            const servicePortId = `eth1/${servicePortNum}/1`;
            const serviceElem = document.querySelector(`[data-port="${servicePortId}"]`);
            if (serviceElem && !serviceElem.classList.contains('hidden') && canConnect(servicePortId)) {
                connections[servicePortId] = servicePortId;
                serviceElem.classList.add('connected');
                const serviceKey = [servicePortId, servicePortId].sort().join('-');
                if (!connectionColors[serviceKey]) connectionColors[serviceKey] = getNextColor();
                applyConnColorToPort(servicePortId, connectionColors[serviceKey]);
            } else if (serviceElem) {
                skippedCount++;
                console.log(`Skipping service port ${servicePortId} (not present in transceivers)`);
            }

            if (portCount === 1) {
                // 1-port mode: pair consecutive ports (skip service port and check transceiver presence)
                for (let i = 1; i <= totalPorts; i += 2) {
                    // Stop if we've exceeded the port count
                    if (i + 1 > totalPorts) {
                        console.log(`Stopping at port ${i} (would exceed totalPorts ${totalPorts})`);
                        break;
                    }

                    // Skip pairs that include the service port
                    if (i === servicePortNum || (i + 1) === servicePortNum) {
                        console.log(`Skipping pair ${i}-${i + 1} (includes service port ${servicePortNum})`);
                        continue;
                    }

                    const port1Id = `eth1/${i}/1`;
                    const port2Id = `eth1/${i + 1}/1`;

                    // Check if both ports can be connected
                    if (!canConnect(port1Id) || !canConnect(port2Id)) {
                        skippedCount += 2;
                        console.log(`Skipping connection ${port1Id} - ${port2Id} (not present in transceivers)`);
                        continue;
                    }

                    const elem1 = document.querySelector(`[data-port="${port1Id}"]`);
                    const elem2 = document.querySelector(`[data-port="${port2Id}"]`);

                    if (elem1 && elem2 && !elem1.classList.contains('hidden') && !elem2.classList.contains('hidden')) {
                        connections[port1Id] = port2Id;
                        connections[port2Id] = port1Id;
                        elem1.classList.add('connected');
                        elem2.classList.add('connected');
                        // assign color
                        const key = [port1Id, port2Id].sort().join('-');
                        if (!connectionColors[key]) connectionColors[key] = getNextColor();
                        // apply to port boxes
                        applyConnColorToPort(port1Id, connectionColors[key]);
                        applyConnColorToPort(port2Id, connectionColors[key]);
                        console.log(`Connected ${port1Id} ‚Üî ${port2Id}`);
                    } else {
                        console.log(`Failed to connect ${port1Id} - ${port2Id}: elem1=${!!elem1}, elem2=${!!elem2}, hidden1=${elem1?.classList.contains('hidden')}, hidden2=${elem2?.classList.contains('hidden')}`);
                    }
                }
            } else if (portCount === 2) {
                // 2-port mode: pair consecutive ports with their /1 and /5 (check transceiver presence)
                for (let i = 1; i <= totalPorts; i += 2) {
                    // Skip pairs that include the service port
                    if (i === servicePortNum || (i + 1) === servicePortNum) {
                        console.log(`Skipping pair ${i}-${i + 1} (includes service port ${servicePortNum})`);
                        continue;
                    }

                    // Stop if we've exceeded the port count
                    if (i + 1 > totalPorts) {
                        console.log(`Stopping at port ${i} (would exceed totalPorts ${totalPorts})`);
                        break;
                    }

                    // Connect port i/1 to port (i+1)/1
                    const port1_1 = `eth1/${i}/1`;
                    const port2_1 = `eth1/${i + 1}/1`;

                    // Check if both ports can be connected
                    if (canConnect(port1_1) && canConnect(port2_1)) {
                        const elem1_1 = document.querySelector(`[data-port="${port1_1}"]`);
                        const elem2_1 = document.querySelector(`[data-port="${port2_1}"]`);

                        if (elem1_1 && elem2_1 && !elem1_1.classList.contains('hidden') && !elem2_1.classList.contains('hidden')) {
                            connections[port1_1] = port2_1;
                            connections[port2_1] = port1_1;
                            elem1_1.classList.add('connected');
                            elem2_1.classList.add('connected');
                            const key1 = [port1_1, port2_1].sort().join('-');
                            if (!connectionColors[key1]) connectionColors[key1] = getNextColor();
                            applyConnColorToPort(port1_1, connectionColors[key1]);
                            applyConnColorToPort(port2_1, connectionColors[key1]);
                        }
                    } else {
                        skippedCount += 2;
                        console.log(`Skipping connection ${port1_1} - ${port2_1} (not present in transceivers)`);
                    }

                    // Connect port i/5 to port (i+1)/5
                    const port1_5 = `eth1/${i}/5`;
                    const port2_5 = `eth1/${i + 1}/5`;

                    // Check if both ports can be connected
                    if (canConnect(port1_5) && canConnect(port2_5)) {
                        const elem1_5 = document.querySelector(`[data-port="${port1_5}"]`);
                        const elem2_5 = document.querySelector(`[data-port="${port2_5}"]`);

                        if (elem1_5 && elem2_5 && !elem1_5.classList.contains('hidden') && !elem2_5.classList.contains('hidden')) {
                            connections[port1_5] = port2_5;
                            connections[port2_5] = port1_5;
                            elem1_5.classList.add('connected');
                            elem2_5.classList.add('connected');
                            const key5 = [port1_5, port2_5].sort().join('-');
                            if (!connectionColors[key5]) connectionColors[key5] = getNextColor();
                            applyConnColorToPort(port1_5, connectionColors[key5]);
                            applyConnColorToPort(port2_5, connectionColors[key5]);
                        }
                    } else {
                        skippedCount += 2;
                        console.log(`Skipping connection ${port1_5} - ${port2_5} (not present in transceivers)`);
                    }
                }
            }

            drawAllConnections();

            // Count total connections created
            const totalConnections = Object.keys(connections).length / 2; // Divide by 2 because bidirectional
            let statusMsg;
            if (presentTransceivers.size > 0) {
                statusMsg = `Quick connect completed: ${totalConnections} connection pair(s) (Profile ${firstProfile}, ${portCount} port${portCount > 1 ? 's' : ''}) + Service Port ${servicePortNum} (Profile ${serviceProfile}, ${serviceSpeed}) | Skipped ${skippedCount} ports | Based on ${presentTransceivers.size / 8} present transceivers`;
            } else {
                statusMsg = `Quick connect completed: ${totalConnections} connection pair(s) (Profile ${firstProfile}, ${portCount} port${portCount > 1 ? 's' : ''}) + Service Port ${servicePortNum} (Profile ${serviceProfile}, ${serviceSpeed}) | No transceiver data - connected all available ports`;
            }
            updateStatus(statusMsg);
        }

        function clearAllConnections() {
            connections = {};
            connectionColors = {};
            nextColorIndex = 0;
            document.querySelectorAll('.port-slot').forEach(slot => {
                if (!slot || !slot.classList) return;
                slot.classList.remove('selected', 'connected', 'glowing');
                slot.style.boxShadow = '';
                slot.style.borderColor = '';
                slot.style.background = '';
                const inner = slot.closest('.inner-frame');
                if (inner) inner.style.borderColor = '';
            });
            // remove any glow classes from svg paths
            document.querySelectorAll('svg [data-conn]').forEach(p => {
                p.classList.remove('connection-glow');
            });
            selectedPort = null;
            drawAllConnections();
            updateStatus('All connections cleared');
        }

        function updateStatus(message, isHTML = false) {
            const statusEl = document.getElementById('status');
            if (isHTML) {
                statusEl.innerHTML = message;
            } else {
                statusEl.textContent = message;
            }
            // Auto scroll to bottom when content updates
            statusEl.scrollTop = statusEl.scrollHeight;
        }

        // Show file selection modal for button click
        function showTopologyFileSelector() {
            showFileSelectionModal(currentPlatform);
        }

        // Show file selection modal
        let selectedTopologyFile = null;
        let currentLoadedTopologyFile = null;  // Track currently loaded topology file

        // Debug: Log version on page load
        console.log('[NUI.html] Version: 2026-01-02-SYNC - currentLoadedTopologyFile tracking enabled');
        console.log('[NUI.html] Initial value:', currentLoadedTopologyFile);

        function showFileSelectionModal(platform) {
            const modal = document.getElementById('fileSelectionModal');
            const platformName = document.getElementById('modalPlatformName');
            const fileList = document.getElementById('fileList');
            const fileNameInput = document.getElementById('topologyFileName');
            const selectedDisplay = document.getElementById('selectedFileDisplay');

            platformName.textContent = platform;
            fileList.innerHTML = '<div style="text-align: center; color: #95a5a6;">Loading...</div>';
            fileNameInput.value = '';
            selectedDisplay.textContent = '';
            selectedTopologyFile = null;
            modal.classList.add('active');

            // Fetch available files for the platform
            fetch(`/api/topology_files/${platform}`)
                .then(r => r.json())
                .then(data => {
                    const files = data.files || [];
                    if (files.length === 0) {
                        fileList.innerHTML = '<div style="text-align: center; color: #e74c3c;">No topology files available for this platform</div>';
                        return;
                    }

                    fileList.innerHTML = '';
                    files.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.textContent = file;
                        fileItem.onclick = () => {
                            // Remove previous selection
                            document.querySelectorAll('.file-item').forEach(item => {
                                item.classList.remove('selected');
                            });
                            // Mark as selected
                            fileItem.classList.add('selected');
                            selectedTopologyFile = file;
                            fileNameInput.value = file;
                            selectedDisplay.textContent = `Selected: ${file}`;
                        };
                        fileList.appendChild(fileItem);
                    });
                })
                .catch(err => {
                    console.error(err);
                    fileList.innerHTML = '<div style="text-align: center; color: #e74c3c;">Failed to load file list</div>';
                });
        }

        function closeFileSelectionModal() {
            const modal = document.getElementById('fileSelectionModal');
            modal.classList.remove('active');
            selectedTopologyFile = null;
        }

        // Load selected or entered topology file
        function loadSelectedTopology() {
            const fileNameInput = document.getElementById('topologyFileName');
            const fileName = fileNameInput.value.trim();

            if (!fileName) {
                updateStatus('Error: Please select or enter a file name');
                return;
            }

            closeFileSelectionModal();
            loadTopologyFile(currentPlatform, fileName);
        }

        // Save current topology to file
        function saveCurrentTopology() {
            const fileNameInput = document.getElementById('topologyFileName');
            let fileName = fileNameInput.value.trim();

            // Auto-detect platform filename mapping
            const platformFileMap = {
                'MINIPACK3BA': 'montblanc.materialized_JSON',
                'MINIPACK3N': 'minipack3n.materialized_JSON',
                'WEDGE800BACT': 'wedge800bact.materialized_JSON',
                'WEDGE800CACT': 'wedge800bact.materialized_JSON'
            };

            // If no filename provided, use default for platform
            if (!fileName) {
                fileName = platformFileMap[currentPlatform] || 'topology.materialized_JSON';
                fileNameInput.value = fileName;
            }

            // Collect current connections
            const connectionsList = [];
            const processed = new Set();

            for (const [port1, port2] of Object.entries(connections)) {
                const key = [port1, port2].sort().join('-');
                if (processed.has(key)) continue;
                processed.add(key);

                // Get profile for each port
                const elem1 = document.querySelector(`[data-port="${port1}"]`);
                const elem2 = document.querySelector(`[data-port="${port2}"]`);

                if (!elem1 || !elem2) continue;

                const container1 = elem1.closest('.port-container');
                const container2 = elem2.closest('.port-container');

                const profile1 = parseInt(container1.dataset.profile) || 0;
                const profile2 = parseInt(container2.dataset.profile) || 0;

                connectionsList.push({
                    port1: port1,
                    port2: port2,
                    profile1: profile1,
                    profile2: profile2
                });
            }

            if (connectionsList.length === 0) {
                updateStatus('Error: No connections to save');
                return;
            }

            updateStatus(`Saving topology... (Platform: ${currentPlatform})`);

            fetch('/api/save_topology', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    platform: currentPlatform,
                    filename: fileName,
                    connections: connectionsList
                })
            })
                .then(r => {
                    if (!r.ok) {
                        return r.text().then(text => {
                            throw new Error(`Save failed: ${r.status} - ${text}`);
                        });
                    }
                    return r.json();
                })
                .then(data => {
                    updateStatus(`‚úì Save successful: Topology/${currentPlatform}/${data.file} (${connectionsList.length} connection(s))`);
                    closeFileSelectionModal();
                })
                .catch(err => {
                    console.error(err);
                    updateStatus('Failed to save topology: ' + err.message);
                });
        }

        // Load parsed topology from backend and apply to UI
        function loadTopology() {
            updateStatus('Loading topology...');
            fetch(`/api/topology/${currentPlatform}`)
                .then(r => {
                    if (!r.ok) throw new Error('fetch failed ' + r.status);
                    return r.json();
                })
                .then(data => {
                    const conns = data.connections || [];
                    applyTopology(conns);

                    // Format profile statistics
                    let statusMsg = `Load completed: ${conns.length} connection(s)`;
                    let isHTML = false;
                    if (data.profile_stats) {
                        statusMsg += formatProfileStats(data.profile_stats, currentPlatform, 'default');
                        isHTML = true;
                    }
                    updateStatus(statusMsg, isHTML);
                })
                .catch(err => {
                    console.error(err);
                    updateStatus('Failed to load topology: ' + err.message);
                });
        }

        // Load topology for a specific platform and filename
        function loadTopologyFile(platform, filename) {
            updateStatus('Loading topology...');
            const q = filename ? `?file=${encodeURIComponent(filename)}` : '';
            fetch(`/api/topology/${platform}${q}`)
                .then(r => {
                    if (!r.ok) throw new Error('fetch failed ' + r.status + ' ' + r.statusText);
                    return r.json();
                })
                .then(data => {
                    const conns = data.connections || [];
                    // if we loaded a topology for a different platform, switch UI
                    if (platform !== currentPlatform) {
                        currentPlatform = platform;

                        // Store platform in sessionStorage for dashboard
                        sessionStorage.setItem('selectedPlatform', platform);
                        console.log('[loadTopologyFile] Platform switched to:', platform);

                        document.querySelectorAll('.platform-btn').forEach(btn => btn.classList.remove('active'));
                        const btn = Array.from(document.querySelectorAll('.platform-btn')).find(b => b.textContent.trim() === platform);
                        if (btn) btn.classList.add('active');
                        clearAllConnections();
                        generatePorts();

                        // Refresh Run Test tab topology file list when platform changes
                        loadTopologyFiles(platform);
                    }

                    // Store the loaded topology filename
                    currentLoadedTopologyFile = filename;
                    console.log('[loadTopologyFile] Set currentLoadedTopologyFile to:', currentLoadedTopologyFile);

                    applyTopology(conns);

                    // Format profile statistics
                    let statusMsg = `Load completed: ${conns.length} connection(s) (${platform} / ${filename || 'default'})`;
                    let isHTML = false;
                    if (data.profile_stats) {
                        statusMsg += formatProfileStats(data.profile_stats, platform, filename);
                        isHTML = true;
                    }
                    updateStatus(statusMsg, isHTML);
                })
                .catch(err => {
                    console.error(err);
                    updateStatus('Failed to load topology: ' + err.message);
                });
        }

        // Format profile statistics for display
        function formatProfileStats(stats, platform, filename) {
            if (!stats || !stats.profile_stats) return '';

            let msg = '<br><br>';

            // Sort profiles by ID
            const profiles = Object.entries(stats.profile_stats)
                .sort((a, b) => parseInt(a[0]) - parseInt(b[0]));

            // Display each profile with padding and colored profile ID
            for (const [profileId, info] of profiles) {
                const pid = parseInt(profileId);
                const profileConfig = profileConfigs[pid];
                const color = profileConfig ? profileConfig.color : '#FFD700';

                const shortName = info.short_name.padEnd(8); // P39 -> "P39     "
                const profileName = info.name.padEnd(45);    // Profile name with padding

                // Color the profile ID (first part)
                msg += `<span style="color: ${color}; font-weight: bold;">${shortName}</span>: ${profileName}: ${info.count} connections<br>`;
            }

            // Display totals
            msg += `Total   :<br>`;
            msg += `Optical : ${stats.total_optical}<br>`;
            msg += `Copper  : ${stats.total_copper}`;
            if (stats.total_unknown > 0) {
                msg += `<br>Unknown : ${stats.total_unknown}`;
            }

            return msg;
        }

        function applyTopology(conns) {
            console.log('üü¢ applyTopology called with', conns.length, 'connections');
            console.log('   First connection:', conns[0]);
            clearAllConnections();
            // conns: [{src, dst, profileID}, ...] OR [{port1, port2, profile1, profile2}, ...]
            let appliedCount = 0;
            for (const c of conns) {
                // Handle both old format (src/dst) and new format (port1/port2)
                const a = c.src || c.port1;
                const b = c.dst || c.port2;
                const profileID = c.profileID || c.profile1;

                if (!a || !b) {
                    console.warn('‚ö†Ô∏è Invalid connection (missing ports):', c);
                    continue;
                }

                // if topology provides profileID, update port container visuals
                if (profileID) {
                    setPortProfile(a, profileID);
                    setPortProfile(b, profileID);
                }
                const slotA = document.querySelector(`[data-port="${a}"]`);
                const slotB = document.querySelector(`[data-port="${b}"]`);
                // If slots not present in UI, skip
                if (!slotA || !slotB) {
                    console.warn('‚ö†Ô∏è Port elements not found:', a, '‚Üí', b, 'slotA:', !!slotA, 'slotB:', !!slotB);
                    continue;
                }

                connections[a] = b;
                connections[b] = a;
                appliedCount++;

                const key = [a, b].sort().join('-');
                // color by profileID if provided, but vary slightly per connection for distinction
                let color = null;
                if (profileID && profileConfigs[profileID] && profileConfigs[profileID].color) {
                    const base = profileConfigs[profileID].color;
                    // produce deterministic variation from key
                    let seed = 0;
                    for (let i = 0; i < key.length; i++) seed = (seed * 31 + key.charCodeAt(i)) & 0xffffffff;
                    color = varyColor(base, seed);
                    connectionColors[key] = color;
                } else {
                    if (!connectionColors[key]) connectionColors[key] = getNextColor();
                    color = connectionColors[key];
                }

                slotA.classList.add('connected');
                slotB.classList.add('connected');
                applyConnColorToPort(a, color);
                applyConnColorToPort(b, color);
            }

            console.log('‚úÖ applyTopology finished:', appliedCount, 'connections applied');
            console.log('   connections object now has', Object.keys(connections).length, 'entries');

            // draw after a small delay to allow layout to settle
            setTimeout(() => {
                drawAllConnections();
                // Reapply absent port styles after topology is loaded
                applyAbsentPortStyles();
            }, 60);
        }

        // Set a port container's profile visually according to topology profileID
        function setPortProfile(portId, profileID) {
            try {
                const prof = parseInt(profileID);
                if (!profileConfigs[prof]) return;
                const slot = document.querySelector(`[data-port="${portId}"]`);
                if (!slot) return;
                const container = slot.closest('.port-container');
                if (!container) return;

                const cfg = profileConfigs[prof];
                container.dataset.profile = prof;
                container.dataset.mode = cfg.speed;

                // Update only THIS slot's labels
                const speedLabel = slot.querySelector('.speed-label');
                if (speedLabel) speedLabel.textContent = cfg.speed;

                const profileLabel = slot.querySelector('.profile-label');
                if (profileLabel) profileLabel.textContent = `P${prof}`;

                const innerFrame = container.querySelector('.inner-frame');
                if (innerFrame) {
                    innerFrame.className = `inner-frame profile-${prof}`;
                }

                const ports = container.querySelectorAll('.port-slot');
                if (cfg.layout === '1,3') {
                    if (ports[0]) ports[0].classList.remove('hidden');
                    if (ports[1]) ports[1].classList.remove('hidden');
                    if (ports[2]) ports[2].classList.add('hidden');
                    if (ports[3]) ports[3].classList.add('hidden');
                } else if (cfg.ports === 1) {
                    // Show only first port
                    if (ports[0]) ports[0].classList.remove('hidden');
                    for (let i = 1; i < ports.length; i++) {
                        if (ports[i]) ports[i].classList.add('hidden');
                    }
                } else if (cfg.ports === 2) {
                    // Show first two ports (handles both /1,/5 and /1,/2 patterns)
                    if (ports[0]) ports[0].classList.remove('hidden');
                    if (ports.length === 2) {
                        // Service port with only 2 sub-ports
                        if (ports[1]) ports[1].classList.remove('hidden');
                    } else {
                        // Regular port with /1, /3, /5, /7
                        if (ports[1]) ports[1].classList.add('hidden');
                        if (ports[2]) ports[2].classList.remove('hidden');
                        if (ports[3]) ports[3].classList.add('hidden');
                    }
                }
            } catch (e) { /* ignore */ }
        }

        // Hover handlers: highlight connected pair and their path
        function portHover(e, slot) {
            try {
                const portId = slot.dataset.port;
                const peer = connections[portId];
                if (!peer) return;
                const key = [portId, peer].sort().join('-');
                const color = connectionColors[key] || '#FFD700';

                // highlight both slots
                const peerSlot = document.querySelector(`[data-port="${peer}"]`);
                slot.classList.add('glowing');
                slot.style.boxShadow = `0 0 14px ${color}`;
                slot.style.borderColor = color;
                if (peerSlot) {
                    peerSlot.classList.add('glowing');
                    peerSlot.style.boxShadow = `0 0 14px ${color}`;
                    peerSlot.style.borderColor = color;
                }

                // highlight the connecting path(s)
                const path = document.querySelector(`svg [data-conn="${key}"]`);
                if (path) {
                    path.classList.add('connection-glow');
                    // slightly increase stroke width on hover
                    path.style.strokeWidth = '3.5';
                }
            } catch (err) { }
        }

        function portLeave(e, slot) {
            try {
                const portId = slot.dataset.port;
                const peer = connections[portId];
                if (!peer) return;
                const key = [portId, peer].sort().join('-');

                const peerSlot = document.querySelector(`[data-port="${peer}"]`);
                slot.classList.remove('glowing');
                slot.style.boxShadow = '';
                slot.style.borderColor = '';
                if (peerSlot) {
                    peerSlot.classList.remove('glowing');
                    peerSlot.style.boxShadow = '';
                    peerSlot.style.borderColor = '';
                }

                const path = document.querySelector(`svg [data-conn="${key}"]`);
                if (path) {
                    path.classList.remove('connection-glow');
                    path.style.strokeWidth = '';
                }
            } catch (err) { }
        }

        window.addEventListener('resize', drawAllConnections);
        window.addEventListener('scroll', drawAllConnections);

        // Load and display version
        function loadVersion() {
            fetch('/VERSION')
                .then(r => r.text())
                .then(version => {
                    const versionDisplay = document.getElementById('versionDisplay');
                    if (versionDisplay) {
                        versionDisplay.textContent = version.trim();
                    }
                })
                .catch(err => {
                    console.log('Failed to load version:', err);
                });
        }

        // Apply topology configuration by running reconvert.py
        function applyTopologyConfig() {
            if (Object.keys(connections).length === 0) {
                updateStatus('Error: No connections to apply');
                return;
            }

            const confirmed = confirm('Are you sure you want to save the topology and run reconvert.py to apply the configuration?');
            if (!confirmed) return;

            // Auto-detect platform filename mapping
            const platformFileMap = {
                'MINIPACK3BA': 'montblanc.materialized_JSON',
                'MINIPACK3N': 'minipack3n.materialized_JSON',
                'WEDGE800BACT': 'wedge800bact.materialized_JSON',
                'WEDGE800CACT': 'wedge800bact.materialized_JSON'
            };

            const fileName = platformFileMap[currentPlatform] || 'topology.materialized_JSON';

            // Collect current connections
            const connectionsList = [];
            const processed = new Set();

            for (const [port1, port2] of Object.entries(connections)) {
                const key = [port1, port2].sort().join('-');
                if (processed.has(key)) continue;
                processed.add(key);

                const elem1 = document.querySelector(`[data-port="${port1}"]`);
                const elem2 = document.querySelector(`[data-port="${port2}"]`);

                if (!elem1 || !elem2) continue;

                const container1 = elem1.closest('.port-container');
                const container2 = elem2.closest('.port-container');

                const profile1 = parseInt(container1.dataset.profile) || 0;
                const profile2 = parseInt(container2.dataset.profile) || 0;

                connectionsList.push({
                    port1: port1,
                    port2: port2,
                    profile1: profile1,
                    profile2: profile2
                });
            }

            // Step 1: Save topology to Topology/<platform>/<filename>
            updateStatus(`Step 1/2: Saving topology to Topology/${currentPlatform}/${fileName}...`);

            fetch('/api/save_topology', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    platform: currentPlatform,
                    filename: fileName,
                    connections: connectionsList
                })
            })
                .then(r => {
                    if (!r.ok) {
                        return r.text().then(text => {
                            throw new Error(`Save failed: ${r.status} - ${text}`);
                        });
                    }
                    return r.json();
                })
                .then(data => {
                    updateStatus(`Step 2/2: Running reconvert.py (Platform: ${currentPlatform})...`);

                    const requestBody = {
                        platform: currentPlatform,
                        config_filename: currentLoadedTopologyFile  // Pass the loaded topology filename
                    };
                    console.log('[DEBUG] Sending to API:', JSON.stringify(requestBody));

                    // Step 2: Run reconvert.py with optional config filename parameter
                    return fetch('/api/apply_topology', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    });
                })
                .then(r => {
                    if (!r.ok) {
                        return r.json().then(data => {
                            throw new Error(data.error || `Execution failed: ${r.status}`);
                        });
                    }
                    return r.json();
                })
                .then(data => {
                    if (data.success) {
                        updateStatus(`‚úì Apply topology successful: ${data.message || ''}`);
                    } else {
                        updateStatus(`‚úó Apply topology failed: ${data.error || ''}`);
                    }
                })
                .catch(err => {
                    console.error(err);
                    updateStatus('Failed to apply topology: ' + err.message);
                });
        }

        generatePorts();
        loadVersion();
        loadAbsentPorts(); // Load absent ports on startup
        loadPresentTransceivers(); // Load present transceivers on startup

        // On load, attempt to detect platform from FRUID and auto-load preferred initial topology
        function detectAndLoadInitial() {
            fetch('/api/detect_initial')
                .then(r => r.json())
                .then(j => {
                    if (j && j.platform) {
                        // use returned platform and preferred file if present
                        const p = j.platform;
                        const f = j.preferred_file || null;
                        // switch UI buttons and regenerate ports
                        currentPlatform = p;

                        // Store platform in sessionStorage for dashboard
                        sessionStorage.setItem('selectedPlatform', p);
                        console.log('[Platform Detection] Platform detected and set to:', p);

                        document.querySelectorAll('.platform-btn').forEach(btn => btn.classList.remove('active'));
                        const btn = Array.from(document.querySelectorAll('.platform-btn')).find(b => b.textContent.trim() === p);
                        if (btn) btn.classList.add('active');
                        clearAllConnections();
                        generatePorts();
                        loadAbsentPorts(); // Reload absent ports when platform is detected

                        // Refresh Run Test tab topology file list when platform is detected
                        loadTopologyFiles(p);

                        if (f) {
                            loadTopologyFile(p, f);
                            return;
                        }
                        // fallback to default topology for platform
                        loadTopology();
                    }
                })
                .catch(err => { console.warn('Detect initial platform failed', err); });
        }

        // invoke detection shortly after initial render
        setTimeout(detectAndLoadInitial, 120);

        // Poll backend for service statuses and update header LEDs
        function updateServiceIndicators(status) {
            try {
                console.log('Service status received:', status);
                const qsfp = document.getElementById('qsfpLed');
                const sai = document.getElementById('saiLed');
                if (qsfp) {
                    if (status && status['qsfp_service']) {
                        qsfp.classList.remove('off');
                        qsfp.classList.add('blink');
                        qsfp.title = 'qsfp_service: running';
                    } else {
                        qsfp.classList.remove('blink');
                        qsfp.classList.add('off');
                        qsfp.title = 'qsfp_service: not running';
                    }
                }
                if (sai) {
                    if (status && status['sai_mono_link_test-sai_impl']) {
                        sai.classList.remove('off');
                        sai.classList.add('blink');
                        // Show current test details if available
                        const msg = status['sai_mono_link_test-sai_impl_message'];
                        const filt = status['sai_mono_link_test-sai_impl_filter'];
                        const cmd = status['sai_mono_link_test-sai_impl_cmd'];
                        console.log('SAI details:', { msg, filt, cmd });
                        if (msg && typeof msg === 'string') {
                            sai.title = msg;
                            console.log('Set SAI tooltip to:', msg);
                        } else if (filt) {
                            const tooltip = `sai_mono_link_test-sai_impl --gtest_filter=${filt}\nCurrently testing ${filt}`;
                            sai.title = tooltip;
                            console.log('Set SAI tooltip (from filter) to:', tooltip);
                        } else {
                            sai.title = 'sai_mono_link_test-sai_impl: running';
                            console.log('Set SAI tooltip to default: running');
                        }
                    } else {
                        sai.classList.remove('blink');
                        sai.classList.add('off');
                        sai.title = 'sai_mono_link_test-sai_impl: not running';
                    }
                }
            } catch (e) {
                console.error('Error updating service indicators:', e);
            }
        }

        function pollServiceStatus() {
            fetch('/api/service_status')
                .then(r => r.ok ? r.json() : null)
                .then(j => updateServiceIndicators(j))
                .catch(() => updateServiceIndicators(null));
        }

        // Poll port status and update port colors
        function updatePortColors(portData) {
            try {
                if (!portData || !portData.ports) {
                    console.warn('No port data available:', portData);
                    return;
                }

                console.log('Port data received:', portData);
                console.log('Port entries:', Object.entries(portData.ports).slice(0, 5));

                // Clear all port status classes first
                document.querySelectorAll('.port-slot').forEach(slot => {
                    slot.classList.remove('link-up', 'link-down', 'link-error');
                });

                // Update absent ports list
                const newAbsentPorts = new Set();

                // Apply new status based on LinkState
                let updatedCount = 0;
                for (const [portName, statusVal] of Object.entries(portData.ports)) {
                    const slot = document.querySelector(`[data-port="${portName}"]`);
                    if (!slot) {
                        if (updatedCount < 3) console.warn(`Port slot not found: ${portName}`);
                        continue;
                    }

                    // Support both old (string) and new (object) formats
                    let linkState = typeof statusVal === 'string' ? statusVal : (statusVal && statusVal.link);
                    const mismatched = typeof statusVal === 'object' && statusVal && (statusVal.mismatchedNeighbor || statusVal.error === 'MISMATCHED_NEIGHBOR');
                    const transceiverPresent = typeof statusVal === 'object' ? (statusVal.transceiverPresent !== false) : true;

                    // Track absent ports
                    if (!transceiverPresent) {
                        newAbsentPorts.add(portName);
                    }

                    if (mismatched) {
                        slot.classList.add('link-error');
                        updatedCount++;
                    } else if (linkState === 'Up') {
                        slot.classList.add('link-up');
                        updatedCount++;
                    } else {
                        slot.classList.add('link-down');
                        updatedCount++;
                    }
                }

                // Update global absent ports set and apply styles
                absentPorts = newAbsentPorts;
                applyAbsentPortStyles();

                console.log(`Updated ${updatedCount} port colors from ${Object.keys(portData.ports).length} ports`);
                console.log(`Found ${absentPorts.size} absent ports`);
            } catch (e) {
                console.error('Error updating port colors:', e);
            }
            // Redraw connections so lines reflect error state colors
            try { drawAllConnections(); } catch (e) { }
        }

        function pollPortStatus() {
            fetch('/api/port_status')
                .then(r => {
                    console.log('Port status response:', r.status);
                    return r.ok ? r.json() : null;
                })
                .then(j => {
                    console.log('Port status data:', j);
                    updatePortColors(j);
                })
                .catch(err => {
                    console.log('Port status poll error:', err.message);
                });
        }

        // start polling every 1s
        setInterval(pollServiceStatus, 1000);
        // do an immediate first poll
        setTimeout(pollServiceStatus, 200);

        // Start polling port status every 30s (fboss2 show port can take up to 20s)
        setInterval(pollPortStatus, 30000);
        setTimeout(pollPortStatus, 1000);

        // Draw upstream/downstream group boxes for wedge platforms
        // This version computes visual rows by clustering element center Ys so
        // the top two visual rows are upstream and the bottom two are downstream.
        function drawGroupBoxes() {
            const container = document.getElementById('mainContainer');
            const groupRoot = document.getElementById('groupBoxes');
            if (!container || !groupRoot) return;
            groupRoot.innerHTML = '';

            if (!currentPlatform.startsWith('WEDGE')) return; // only for wedge platforms

            // Use the full port container elements so the boxes include profile frames
            // but exclude the physical port 33 (eth1/33/x) from group box calculations
            const primaryElems = Array.from(document.querySelectorAll('.port-container')).filter(el => {
                const firstSlot = el.querySelector('.port-slot');
                if (!firstSlot) return true;
                const dp = firstSlot.dataset.port;
                if (!dp) return true;
                const parts = dp.split('/');
                const num = parseInt(parts[1], 10);
                return num !== 33;
            });
            if (!primaryElems.length) return;

            const containerRect = container.getBoundingClientRect();
            // compute center Y for each port-container relative to container
            const centers = primaryElems.map(el => {
                const r = el.getBoundingClientRect();
                return { el, cy: Math.round(r.top + r.height / 2 - containerRect.top), rect: r };
            });

            // cluster unique center Ys (tolerance 12px)
            const unique = [];
            for (const c of centers) {
                let found = false;
                for (let u of unique) {
                    if (Math.abs(u - c.cy) <= 12) { found = true; break; }
                }
                if (!found) unique.push(c.cy);
            }
            unique.sort((a, b) => a - b);
            if (unique.length < 2) return;

            // choose top two rows as upstream, bottom two as downstream
            const upRows = unique.slice(0, 2);
            const downRows = unique.slice(-2);

            function rectsForRows(rows) {
                return centers.filter(c => rows.some(r => Math.abs(c.cy - r) <= 12)).map(c => c.rect);
            }

            function bboxFromRects(rects) {
                if (!rects.length) return null;
                // extra padding so the group box fully contains profile frames
                const pad = 12;
                const left = Math.min(...rects.map(r => r.left)) - containerRect.left - pad;
                const top = Math.min(...rects.map(r => r.top)) - containerRect.top - pad;
                const right = Math.max(...rects.map(r => r.right)) - containerRect.left + pad;
                const bottom = Math.max(...rects.map(r => r.bottom)) - containerRect.top + pad;
                return { left, top, width: Math.max(40, right - left), height: Math.max(40, bottom - top) };
            }

            const upRects = rectsForRows(upRows);
            const downRects = rectsForRows(downRows);

            const upBox = bboxFromRects(upRects);
            const downBox = bboxFromRects(downRects);

            // If boxes would overlap, nudge downstream box down slightly to avoid overlap
            if (upBox && downBox) {
                const gap = 10; // minimum vertical gap between boxes
                const upBottom = upBox.top + upBox.height;
                if (downBox.top < upBottom + gap) {
                    downBox.top = upBottom + gap;
                }
                // ensure downstream box remains inside container vertically
                const containerH = containerRect.height;
                if (downBox.top + downBox.height > containerH - 8) {
                    downBox.top = Math.max(containerH - downBox.height - 8, upBottom + gap);
                }
            }

            if (upBox) {
                const d = document.createElement('div');
                d.className = 'group-box';
                d.style.left = upBox.left + 'px';
                d.style.top = upBox.top + 'px';
                d.style.width = upBox.width + 'px';
                d.style.height = upBox.height + 'px';
                d.innerHTML = `<div class="label">upstream</div>`;
                groupRoot.appendChild(d);
            }
            if (downBox) {
                const d = document.createElement('div');
                d.className = 'group-box';
                d.style.left = downBox.left + 'px';
                d.style.top = downBox.top + 'px';
                d.style.width = downBox.width + 'px';
                d.style.height = downBox.height + 'px';
                d.innerHTML = `<div class="label">downstream</div>`;
                groupRoot.appendChild(d);
            }
        }

        // Test Info Functions
        let testInfoInterval = null;

        function loadTestInfo() {
            fetch('/api/test_info')
                .then(r => r.ok ? r.json() : null)
                .then(data => {
                    if (data) {
                        displayTestStatus(data);

                        // Stop auto-refresh if test is completed
                        if (data.test_completed || (data.test_results && !data.test_running)) {
                            if (testInfoInterval) {
                                console.log('[Test Info] Test completed, stopping auto-refresh');
                                stopTestInfoAutoRefresh();
                            }
                        }
                    }
                })
                .catch(err => {
                    console.error('Failed to load test info:', err);
                    document.getElementById('testStatusBox').innerHTML =
                        '<div style="text-align: center; color: #F44336;">Failed to load test status</div>';
                });
        }

        function refreshTestInfo() {
            loadTestInfo();
        }

        function startTestInfoAutoRefresh() {
            // Only start if auto-refresh is enabled
            if (!testInfoAutoRefreshEnabled) {
                console.log('Auto-refresh is disabled, not starting');
                return;
            }

            // Clear any existing interval
            if (testInfoInterval) {
                clearInterval(testInfoInterval);
            }
            // Start auto-refresh every 5 seconds
            testInfoInterval = setInterval(loadTestInfo, 5000);
            console.log('Test info auto-refresh started (every 5 seconds)');
        }

        function stopTestInfoAutoRefresh() {
            if (testInfoInterval) {
                clearInterval(testInfoInterval);
                testInfoInterval = null;
                console.log('Test info auto-refresh stopped');
            }
        }

        let logViewerInterval = null;
        let logViewerVisible = false;
        let testInfoAutoRefreshEnabled = true; // Track auto-refresh state

        function toggleAutoRefresh() {
            testInfoAutoRefreshEnabled = !testInfoAutoRefreshEnabled;
            const btn = document.getElementById('autoRefreshToggle');

            if (testInfoAutoRefreshEnabled) {
                btn.textContent = '‚è∏Ô∏è Auto Refresh: ON';
                btn.style.background = 'rgba(76, 175, 80, 0.3)';
                btn.style.color = '#4CAF50';
                btn.style.borderColor = '#4CAF50';
                startTestInfoAutoRefresh();
                console.log('Auto-refresh enabled');
            } else {
                btn.textContent = '‚ñ∂Ô∏è Auto Refresh: OFF';
                btn.style.background = 'rgba(244, 67, 54, 0.3)';
                btn.style.color = '#F44336';
                btn.style.borderColor = '#F44336';
                stopTestInfoAutoRefresh();
                console.log('Auto-refresh disabled');
            }
        }

        function toggleLogViewer() {
            logViewerVisible = !logViewerVisible;
            const content = document.getElementById('logViewerContent');
            const btn = document.getElementById('logViewerToggleBtn');

            if (logViewerVisible) {
                content.style.display = 'block';
                btn.textContent = 'Hide Log';
                btn.style.background = 'rgba(244, 67, 54, 0.3)';
                refreshLogViewer();
                // Auto-refresh every 1 second
                logViewerInterval = setInterval(refreshLogViewer, 1000);
            } else {
                content.style.display = 'none';
                btn.textContent = 'Show Log';
                btn.style.background = '';
                if (logViewerInterval) {
                    clearInterval(logViewerInterval);
                    logViewerInterval = null;
                }
            }
        }

        function refreshLogViewer() {
            fetch('/api/test_log_tail?lines=100')
                .then(r => r.json())
                .then(data => {
                    const textDiv = document.getElementById('logViewerText');
                    const infoDiv = document.getElementById('logViewerInfo');

                    if (data.error) {
                        textDiv.innerHTML = `<div style="color: #F44336;">Error: ${data.error}</div>`;
                        infoDiv.textContent = data.log_file || 'No log file found';
                    } else {
                        // Colorize log output
                        let colorizedContent = data.content
                            .replace(/\[.*?RUN.*?\]/g, '<span style="color: #2196F3; font-weight: bold;">$&</span>')
                            .replace(/\[.*?OK.*?\]/g, '<span style="color: #4CAF50; font-weight: bold;">$&</span>')
                            .replace(/\[.*?PASSED.*?\]/g, '<span style="color: #4CAF50; font-weight: bold;">$&</span>')
                            .replace(/\[.*?FAILED.*?\]/g, '<span style="color: #F44336; font-weight: bold;">$&</span>')
                            .replace(/\[.*?ERROR.*?\]/g, '<span style="color: #F44336; font-weight: bold;">$&</span>')
                            .replace(/\[.*?WARN.*?\]/g, '<span style="color: #FFC107; font-weight: bold;">$&</span>');

                        textDiv.innerHTML = colorizedContent;
                        infoDiv.textContent = `${data.log_file} (${data.lines} lines, auto-refresh every 1s)`;

                        // Auto-scroll to bottom
                        textDiv.scrollTop = textDiv.scrollHeight;
                    }
                })
                .catch(err => {
                    console.error('Failed to load log:', err);
                });
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function displayTestStatus(data) {
            const statusBox = document.getElementById('testStatusBox');
            const resultsSection = document.getElementById('testResultsSection');
            const resultsBody = document.getElementById('testResultsTableBody');
            const logViewerSection = document.getElementById('logViewerSection');

            let html = '';

            // Determine test status indicator
            let testStatusIndicator = '';
            if (data.test_running && data.test_type === 'sai') {
                testStatusIndicator = '<span style="color: #FFC107;">‚óè SAI Test Running</span>';
            } else if (data.test_running && data.test_type === 'link') {
                testStatusIndicator = '<span style="color: #FFC107;">‚óè Link Test Running</span>';
            } else if (data.test_running && data.test_type === 'agent_hw') {
                testStatusIndicator = '<span style="color: #FFC107;">‚óè Agent HW Test Running</span>';
            } else if (data.test_running) {
                testStatusIndicator = '<span style="color: #FFC107;">‚óè Test Running</span>';
            } else if (data.test_completed) {
                testStatusIndicator = '<span style="color: #4CAF50;">‚óè Test Completed</span>';
            } else {
                testStatusIndicator = '<span style="color: #7f8c8d;">‚óè No Test Running</span>';
            }

            const serviceStatusHtml = `
                <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 12px; color: #95a5a6;">Test Status:</span>
                        <span style="font-weight: bold; font-size: 13px;">${testStatusIndicator}</span>
                    </div>
                </div>
            `;

            html = serviceStatusHtml;

            if (data.test_results) {
                // CSV results available - test completed
                const results = data.test_results;

                // Add download links if archive files exist
                let downloadLink = '';

                // Test report archive download
                if (data.archive_file && data.archive_file !== 'N/A') {
                    const archiveName = data.archive_file.split('/').pop();
                    downloadLink += `
                        <div style="background: rgba(33, 150, 243, 0.2); padding: 12px; border-radius: 8px; border-left: 4px solid #2196F3; margin-bottom: 15px;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <div style="font-size: 13px; color: #95a5a6; margin-bottom: 5px;">Test Report Archive:</div>
                                    <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 12px;">${archiveName}</code>
                                </div>
                                <a href="/download_report?file=${encodeURIComponent(data.archive_file)}" 
                                   style="padding: 8px 16px; background: #2196F3; color: white; border-radius: 6px; text-decoration: none; font-size: 13px; font-weight: bold; display: inline-block;">
                                    üì• Download
                                </a>
                            </div>
                        </div>
                    `;
                }


                html += `
                    <div style="margin-bottom: 15px;">
                        <h3 style="color: #4CAF50; margin-bottom: 10px;">‚úì Test Completed</h3>
                        <div style="font-size: 14px; color: #ecf0f1;">
                            <div>Result File: <code style="background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 4px;">${results.file}</code></div>
                        </div>
                    </div>
                    ${downloadLink}
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 15px;">
                        <div style="background: rgba(76, 175, 80, 0.2); padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                            <div style="font-size: 24px; font-weight: bold; color: #4CAF50;">${results.passed}</div>
                            <div style="font-size: 13px; color: #95a5a6; margin-top: 5px;">Passed</div>
                        </div>
                        <div style="background: rgba(244, 67, 54, 0.2); padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
                            <div style="font-size: 24px; font-weight: bold; color: #F44336;">${results.failed}</div>
                            <div style="font-size: 13px; color: #95a5a6; margin-top: 5px;">Failed</div>
                        </div>
                        <div style="background: rgba(33, 150, 243, 0.2); padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3;">
                            <div style="font-size: 24px; font-weight: bold; color: #2196F3;">${results.total}</div>
                            <div style="font-size: 13px; color: #95a5a6; margin-top: 5px;">Total Tests</div>
                        </div>
                    </div>
                `;

                // Show results table
                resultsSection.style.display = 'block';
                resultsBody.innerHTML = results.tests.map((test, idx) => {
                    const isPass = test.result === 'OK' || test.result === 'PASS';
                    const statusColor = isPass ? '#4CAF50' : '#F44336';
                    const statusIcon = isPass ? '‚úì' : '‚úó';
                    return `
                        <tr>
                            <td style="text-align: center;">${idx + 1}</td>
                            <td style="font-family: 'Courier New', monospace; font-size: 12px;">${test.name}</td>
                            <td style="text-align: center; color: ${statusColor}; font-weight: bold;">
                                ${statusIcon} ${test.result}
                            </td>
                        </tr>
                    `;
                }).join('');

            } else if (data.test_running) {
                // Test is currently running
                const passedCount = data.passed_tests ? data.passed_tests.length : 0;
                const failedCount = data.failed_tests ? data.failed_tests.length : 0;
                const testList = data.test_list || [];
                const currentTest = data.current_test || '';
                const passedTests = data.passed_tests || [];
                const failedTests = data.failed_tests || [];

                // Debug: Log first 10 tests to verify order
                console.log('[Test Order] First 10 tests:', testList.slice(0, 10));

                // Determine test type badge
                let testTypeBadge = '';
                if (data.test_type === 'sai') {
                    testTypeBadge = '<span style="background: #9C27B0; color: white; padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: bold;">SAI TEST</span>';
                } else if (data.test_type === 'link') {
                    testTypeBadge = '<span style="background: #FF9800; color: white; padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: bold;">LINK TEST</span>';
                } else if (data.test_type === 'agent_hw') {
                    testTypeBadge = '<span style="background: #00BCD4; color: white; padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: bold;">AGENT HW TEST</span>';
                }

                // Build test checklist
                let checklistHtml = '';
                if (testList.length > 0) {
                    let testingItemIndex = -1;
                    checklistHtml = `
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-size: 14px; color: #ecf0f1; font-weight: bold;">Test Progress Checklist (${testList.length} tests):</div>
                                <button onclick="loadTestInfo()" style="padding: 5px 12px; background: rgba(52, 152, 219, 0.3); color: #3498db; border: 1px solid #3498db; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='rgba(52, 152, 219, 0.5)'" onmouseout="this.style.background='rgba(52, 152, 219, 0.3)'">üîÑ Refresh List</button>
                            </div>
                            <div id="testChecklistContainer" style="max-height: 600px; overflow-y: auto; scroll-behavior: smooth; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; background: rgba(0,0,0,0.2);">
                                ${testList.map((test, index) => {
                        let status = '';
                        let icon = '';
                        let color = '#7f8c8d';

                        // Extract test name for matching
                        const testName = test.split('.').pop();

                        // Check if currently testing (highest priority)
                        if (currentTest && test === currentTest) {
                            status = 'Testing...';
                            icon = '‚è≥';
                            color = '#FFC107';
                            testingItemIndex = index;
                        } else if (passedTests.some(p => {
                            const cleanP = p.split('.').slice(-1)[0] || p;
                            const cleanTest = test.split('.').slice(-1)[0] || test;
                            return p.includes(test) || test.includes(p) || cleanP === cleanTest || p.endsWith(testName);
                        })) {
                            status = 'PASS';
                            icon = '‚úì';
                            color = '#4CAF50';
                        } else if (failedTests.some(f => {
                            const cleanF = f.split('.').slice(-1)[0] || f;
                            const cleanTest = test.split('.').slice(-1)[0] || test;
                            return f.includes(test) || test.includes(f) || cleanF === cleanTest || f.endsWith(testName);
                        })) {
                            status = 'FAIL';
                            icon = '‚úó';
                            color = '#F44336';
                        } else {
                            status = 'Not tested yet';
                            icon = '‚óã';
                            color = '#7f8c8d';
                        }

                        const itemId = status === 'Testing...' ? 'id="currentTestingItem"' : '';
                        return `
                                        <div ${itemId} style="padding: 5px 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.05);">
                                            <span style="font-family: 'Courier New', monospace; font-size: 11px; color: #ecf0f1;">${test}</span>
                                            <span style="color: ${color}; font-weight: bold; font-size: 12px; white-space: nowrap; margin-left: 10px;">${icon} ${status}</span>
                                        </div>
                                    `;
                    }).join('')}
                            </div>
                        </div>
                    `;
                }

                html += `
                    <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <h3 style="color: #FFC107; margin: 0;">‚è≥ Test In Progress</h3>
                        ${testTypeBadge}
                    </div>
                    ${data.log_file ? `<div style="font-size: 13px; color: #95a5a6; margin-bottom: 10px;">Log: <code style="background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 4px;">${data.log_file}</code></div>` : ''}
                    ${data.start_time ? `<div style="font-size: 13px; color: #95a5a6; margin-bottom: 15px;">Started: <code style="background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 4px;">${data.start_time}</code></div>` : ''}
                    ${checklistHtml}
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                            <div style="font-size: 14px; color: #4CAF50; margin-bottom: 8px;">‚úì Passed: ${passedCount}</div>
                            ${passedCount > 0 ? `<div style="max-height: 150px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 11px; color: #95a5a6;">
                                ${data.passed_tests.slice(-10).map(t => `<div style="padding: 2px 0;">‚Ä¢ ${t}</div>`).join('')}
                                ${passedCount > 10 ? `<div style="padding: 2px 0; color: #7f8c8d; font-style: italic;">... and ${passedCount - 10} more</div>` : ''}
                            </div>` : '<div style="font-size: 11px; color: #7f8c8d;">No tests passed yet</div>'}
                        </div>
                        ${failedCount > 0 ? `
                        <div style="background: rgba(244, 67, 54, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
                            <div style="font-size: 14px; color: #F44336; margin-bottom: 8px;">‚úó Failed: ${failedCount}</div>
                            <div style="max-height: 150px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 11px; color: #95a5a6;">
                                ${data.failed_tests.map(t => `<div style="padding: 2px 0; color: #F44336;">‚Ä¢ ${t}</div>`).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                `;
                resultsSection.style.display = 'none';
                logViewerSection.style.display = 'block';

            } else if (data.test_completed && data.log_archive) {
                // Test completed (from TEST_STATUS) with log archive available
                const logFileName = data.log_archive;
                const logFilePath = `/opt/fboss/${logFileName}`;

                html += `
                    <div style="margin-top: 20px;">
                        <h3 style="color: #4CAF50; margin-bottom: 15px;">‚úì Test Completed</h3>
                        <div style="background: rgba(33, 150, 243, 0.2); padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <div style="font-size: 13px; color: #95a5a6; margin-bottom: 5px;">Test Log Archive:</div>
                                    <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 12px;">${logFileName}</code>
                                    <div style="font-size: 12px; color: #7f8c8d; margin-top: 8px;">
                                        <div>Start: ${data.start_time || 'N/A'}</div>
                                        <div>End: ${data.end_time || 'N/A'}</div>
                                    </div>
                                </div>
                                <a href="/download_report?file=${encodeURIComponent(logFilePath)}" 
                                   style="padding: 10px 20px; background: #2196F3; color: white; border-radius: 6px; text-decoration: none; font-size: 14px; font-weight: bold; display: inline-block; transition: background 0.2s;"
                                   onmouseover="this.style.background='#1976D2'"
                                   onmouseout="this.style.background='#2196F3'">
                                    üì• Download Log
                                </a>
                            </div>
                        </div>
                    </div>
                `;
                resultsSection.style.display = 'none';
                logViewerSection.style.display = 'none';

            } else {
                // No test running, no results
                html = `
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 48px; margin-bottom: 15px; opacity: 0.3;">üìã</div>
                        <div style="font-size: 18px; color: #95a5a6; margin-bottom: 10px;">No Test Results Available</div>
                        <div style="font-size: 13px; color: #7f8c8d;">
                            No CSV result files found in /opt/fboss/<br>
                            No test processes currently running
                        </div>
                    </div>
                `;
                resultsSection.style.display = 'none';
                logViewerSection.style.display = 'none';
            }

            statusBox.innerHTML = html;

            // Auto-scroll to current testing item if it exists
            setTimeout(() => {
                const currentTestingItem = document.getElementById('currentTestingItem');
                if (currentTestingItem) {
                    currentTestingItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);

            // Fetch test reports AFTER HTML is rendered (only for completed tests)
            if (data.test_results) {
                console.log('[Test Info] Fetching test reports...');
                fetch('/api/test_reports')
                    .then(response => {
                        console.log('[Test Info] API response status:', response.status);
                        return response.json();
                    })
                    .then(reportData => {
                        console.log('[Test Info] Report data:', reportData);
                        const reportLinkElem = document.getElementById('testReportLink');

                        if (reportData.reports && reportData.reports.length > 0) {
                            const latestReport = reportData.reports[0];
                            const sizeInMB = (latestReport.size / (1024 * 1024)).toFixed(2);
                            console.log('[Test Info] Latest report:', latestReport.filename);

                            if (reportLinkElem) {
                                reportLinkElem.innerHTML = `
                                    <div style="background: rgba(76, 175, 80, 0.15); padding: 12px; border-radius: 8px; border-left: 4px solid #4CAF50; margin-top: 15px;">
                                        <div style="display: flex; align-items: center; justify-content: space-between;">
                                            <div style="flex: 1;">
                                                <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">üì¶ Test Report Available</div>
                                                <div style="font-size: 12px; color: #95a5a6; font-family: 'Courier New', monospace;">${latestReport.filename}</div>
                                                <div style="font-size: 11px; color: #7f8c8d; margin-top: 3px;">Size: ${sizeInMB} MB | Path: ${reportData.report_dir}</div>
                                            </div>
                                            <a href="/api/download_report/${latestReport.filename}" 
                                               download="${latestReport.filename}"
                                               style="background: #4CAF50; color: white; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-weight: bold; font-size: 14px; white-space: nowrap; margin-left: 15px;">
                                                ‚¨á Download
                                            </a>
                                        </div>
                                    </div>
                                `;
                            } else {
                                console.error('[Test Info] testReportLink element not found!');
                            }
                        } else if (reportLinkElem) {
                            // No reports found - show message
                            console.log('[Test Info] No reports found in:', reportData.report_dir);
                            reportLinkElem.innerHTML = `
                                <div style="background: rgba(255, 193, 7, 0.15); padding: 12px; border-radius: 8px; border-left: 4px solid #FFC107; margin-top: 15px;">
                                    <div style="color: #FFC107; font-weight: bold; margin-bottom: 5px;">‚ö† No Test Report Found</div>
                                    <div style="font-size: 12px; color: #95a5a6;">Report directory: ${reportData.report_dir || 'Unknown'}</div>
                                </div>
                            `;
                        }
                    })
                    .catch(err => {
                        console.error('[Test Info] Error fetching test reports:', err);
                        const reportLinkElem = document.getElementById('testReportLink');
                        if (reportLinkElem) {
                            reportLinkElem.innerHTML = `
                                <div style="background: rgba(244, 67, 54, 0.15); padding: 12px; border-radius: 8px; border-left: 4px solid #F44336; margin-top: 15px;">
                                    <div style="color: #F44336; font-weight: bold;">‚úó Error Loading Report</div>
                                    <div style="font-size: 11px; color: #95a5a6; margin-top: 5px;">${err.message}</div>
                                </div>
                            `;
                        }
                    });
            }
        }

        // ============================================================================
        // Run Test Tab Functions
        // ============================================================================

        let testStatusCheckTimer = null;
        let newBinUploaded = false;

        // Load test scripts from API
        // Restore clean_fboss checkbox state from localStorage
        function restoreCleanFbossState() {
            const savedCleanFboss = localStorage.getItem('runtest_clean_fboss');
            if (savedCleanFboss !== null) {
                document.getElementById('cleanFbossCheckbox').checked = (savedCleanFboss === 'true');
            }
        }

        function loadTestScripts() {
            fetch('/api/test/scripts')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('testScriptSelect');
                    select.innerHTML = '<option value="">-- Select Test Script --</option>';

                    if (data.scripts && data.scripts.length > 0) {
                        // Filter out platform_config.sh
                        const filteredScripts = data.scripts.filter(script => script !== 'platform_config.sh');

                        filteredScripts.forEach(script => {
                            const option = document.createElement('option');
                            option.value = script;
                            option.textContent = script;
                            select.appendChild(option);
                        });

                        // Restore last selection
                        const savedScript = localStorage.getItem('runtest_script');
                        if (savedScript && filteredScripts.includes(savedScript)) {
                            select.value = savedScript;
                            onTestScriptChange(); // Trigger to show/hide relevant sections
                        }
                    }
                })
                .catch(err => console.error('Error loading test scripts:', err));
        }

        // Load bin files from API
        function loadBinFiles() {
            fetch('/api/test/bins')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('binFileSelect');
                    select.innerHTML = '<option value="">-- Select Bin File --</option>';

                    if (data.bins && data.bins.length > 0) {
                        data.bins.forEach(bin => {
                            const option = document.createElement('option');
                            option.value = bin.filename;
                            option.textContent = bin.filename;
                            select.appendChild(option);
                        });

                        // Restore last selection
                        const savedBin = localStorage.getItem('runtest_bin');
                        if (savedBin) {
                            select.value = savedBin;
                        }
                    }
                })
                .catch(err => console.error('Error loading bin files:', err));
        }

        // Load topology types from API
        function loadTopologyTypes() {
            fetch('/api/test/topology-types')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('topologyTypeSelect');
                    select.innerHTML = '<option value="">-- Select Topology Type --</option>';

                    if (data.types && data.types.length > 0) {
                        data.types.forEach(type => {
                            const option = document.createElement('option');
                            option.value = type;
                            option.textContent = type;
                            select.appendChild(option);
                        });

                        // Restore last selection or set default
                        const savedTopology = localStorage.getItem('runtest_topology');
                        if (savedTopology && data.types.includes(savedTopology)) {
                            select.value = savedTopology;
                        } else {
                            select.value = 'default';
                        }
                    }
                })
                .catch(err => console.error('Error loading topology types:', err));
        }

        // Load topology files for platform
        function loadTopologyFiles(platform) {
            return fetch(`/api/test/topology-files/${platform}`)
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('topologyFileSelect');
                    select.innerHTML = '<option value="">-- Select Topology File --</option>';

                    if (data.files && data.files.length > 0) {
                        data.files.forEach(file => {
                            const option = document.createElement('option');
                            option.value = file;
                            option.textContent = file;
                            select.appendChild(option);
                        });

                        // Restore last selection
                        const savedFile = localStorage.getItem('runtest_topology_file');
                        if (savedFile && data.files.includes(savedFile)) {
                            select.value = savedFile;
                        }
                    }
                    return data; // Return data for chaining
                })
                .catch(err => {
                    console.error('Error loading topology files:', err);
                    return { files: [] };
                });
        }

        // Toggle test level checkboxes when parent checkbox is clicked
        function toggleTestLevels(testType) {
            let checkbox, levelsDiv, levelCheckboxes;

            if (testType === 'sai') {
                checkbox = document.getElementById('saiTestCheckbox');
                levelsDiv = document.getElementById('saiLevels');
                levelCheckboxes = document.querySelectorAll('.sai-level');
            } else if (testType === 'agenthw') {
                checkbox = document.getElementById('agentHwTestCheckbox');
                levelsDiv = document.getElementById('agentHwLevels');
                levelCheckboxes = document.querySelectorAll('.agenthw-level');
            } else if (testType === 'link') {
                checkbox = document.getElementById('linkTestCheckbox');
                levelsDiv = document.getElementById('linkLevels');
                levelCheckboxes = document.querySelectorAll('.link-level');
            }

            if (checkbox && checkbox.checked) {
                if (levelsDiv) levelsDiv.style.display = 'flex';
                levelCheckboxes.forEach(cb => {
                    // Enable checkboxes that don't have the disabled attribute in HTML
                    // T2 has disabled attribute, so it stays disabled
                    if (!cb.hasAttribute('data-permanently-disabled')) {
                        cb.disabled = false;
                    }
                });
            } else {
                if (levelsDiv) levelsDiv.style.display = 'none';
                levelCheckboxes.forEach(cb => {
                    cb.checked = false;
                    cb.disabled = true;
                });
            }
        }

        // Save all Run Test selections to localStorage
        function saveRunTestSelections() {
            try {
                const selections = {
                    script: document.getElementById('testScriptSelect')?.value || '',
                    bin: document.getElementById('binFileSelect')?.value || '',
                    test_level: document.getElementById('testLevelSelect')?.value || '',
                    topology: Array.from(document.getElementById('topologyTypeSelect')?.selectedOptions || []).map(opt => opt.value).filter(v => v).join(','),
                    topology_file: document.getElementById('topologyFileSelect')?.value || '',
                    clean_fboss: document.getElementById('cleanFbossCheckbox')?.checked || false,
                    // Test items
                    sai_test: document.getElementById('saiTestCheckbox')?.checked || false,
                    sai_t0: document.getElementById('saiT0Checkbox')?.checked || false,
                    sai_t1: document.getElementById('saiT1Checkbox')?.checked || false,
                    sai_t2: document.getElementById('saiT2Checkbox')?.checked || false,
                    agent_test: document.getElementById('agentHwTestCheckbox')?.checked || false,
                    agent_t0: document.getElementById('agentT0Checkbox')?.checked || false,
                    agent_t1: document.getElementById('agentT1Checkbox')?.checked || false,
                    agent_t2: document.getElementById('agentT2Checkbox')?.checked || false,
                    link_test: document.getElementById('linkTestCheckbox')?.checked || false,
                    evt_test: document.getElementById('evtTestCheckbox')?.checked || false
                };
                localStorage.setItem('runtest_selections', JSON.stringify(selections));
                console.log('[Run Test] Saved selections to cache');
            } catch (e) {
                console.error('[Run Test] Error saving selections:', e);
            }
        }

        // Restore all Run Test selections from localStorage
        function restoreRunTestSelections() {
            try {
                const saved = localStorage.getItem('runtest_selections');
                if (!saved) {
                    console.log('[Run Test] No cached selections found');
                    return;
                }

                const selections = JSON.parse(saved);
                console.log('[Run Test] Restoring cached selections:', selections);

                // Restore test items checkboxes
                if (selections.sai_test !== undefined) {
                    const saiCheckbox = document.getElementById('saiTestCheckbox');
                    if (saiCheckbox) saiCheckbox.checked = selections.sai_test;
                }
                if (selections.sai_t0 !== undefined) {
                    const cb = document.getElementById('saiT0Checkbox');
                    if (cb) cb.checked = selections.sai_t0;
                }
                if (selections.sai_t1 !== undefined) {
                    const cb = document.getElementById('saiT1Checkbox');
                    if (cb) cb.checked = selections.sai_t1;
                }
                if (selections.sai_t2 !== undefined) {
                    const cb = document.getElementById('saiT2Checkbox');
                    if (cb) cb.checked = selections.sai_t2;
                }

                if (selections.agent_test !== undefined) {
                    const agentCheckbox = document.getElementById('agentHwTestCheckbox');
                    if (agentCheckbox) agentCheckbox.checked = selections.agent_test;
                }
                if (selections.agent_t0 !== undefined) {
                    const cb = document.getElementById('agentT0Checkbox');
                    if (cb) cb.checked = selections.agent_t0;
                }
                if (selections.agent_t1 !== undefined) {
                    const cb = document.getElementById('agentT1Checkbox');
                    if (cb) cb.checked = selections.agent_t1;
                }
                if (selections.agent_t2 !== undefined) {
                    const cb = document.getElementById('agentT2Checkbox');
                    if (cb) cb.checked = selections.agent_t2;
                }

                if (selections.link_test !== undefined) {
                    const linkCheckbox = document.getElementById('linkTestCheckbox');
                    if (linkCheckbox) linkCheckbox.checked = selections.link_test;
                }
                if (selections.link_t0 !== undefined) {
                    const cb = document.getElementById('linkT0Checkbox');
                    if (cb) cb.checked = selections.link_t0;
                }
                if (selections.link_t1 !== undefined) {
                    const cb = document.getElementById('linkT1Checkbox');
                    if (cb && !cb.disabled) cb.checked = selections.link_t1;
                }
                if (selections.link_t2 !== undefined) {
                    const cb = document.getElementById('linkT2Checkbox');
                    if (cb && !cb.disabled) cb.checked = selections.link_t2;
                }

                if (selections.evt_test !== undefined) {
                    const evtCheckbox = document.getElementById('evtTestCheckbox');
                    if (evtCheckbox) evtCheckbox.checked = selections.evt_test;
                }

                if (selections.clean_fboss !== undefined) {
                    const cleanCheckbox = document.getElementById('cleanFbossCheckbox');
                    if (cleanCheckbox) cleanCheckbox.checked = selections.clean_fboss;
                }

                // Note: Script, bin, test_level, topology, topology_file are restored
                // by their individual load functions (loadTestScripts, loadBinFiles, etc.)
                // which already check localStorage

            } catch (e) {
                console.error('[Run Test] Error restoring selections:', e);
            }
        }

        // Save all Run Test selections to localStorage
        function saveRunTestSelections() {
            try {
                const selections = {
                    script: document.getElementById('testScriptSelect')?.value || '',
                    bin: document.getElementById('binFileSelect')?.value || '',
                    test_level: document.getElementById('testLevelSelect')?.value || '',
                    topology: Array.from(document.getElementById('topologyTypeSelect')?.selectedOptions || []).map(opt => opt.value).filter(v => v).join(','),
                    topology_file: document.getElementById('topologyFileSelect')?.value || '',
                    clean_fboss: document.getElementById('cleanFbossCheckbox')?.checked || false,
                    // Test items
                    sai_test: document.getElementById('saiTestCheckbox')?.checked || false,
                    sai_t0: document.getElementById('saiT0Checkbox')?.checked || false,
                    sai_t1: document.getElementById('saiT1Checkbox')?.checked || false,
                    sai_t2: document.getElementById('saiT2Checkbox')?.checked || false,
                    agent_test: document.getElementById('agentHwTestCheckbox')?.checked || false,
                    agent_t0: document.getElementById('agentT0Checkbox')?.checked || false,
                    agent_t1: document.getElementById('agentT1Checkbox')?.checked || false,
                    agent_t2: document.getElementById('agentT2Checkbox')?.checked || false,
                    link_test: document.getElementById('linkTestCheckbox')?.checked || false,
                    link_t0: document.getElementById('linkT0Checkbox')?.checked || false,
                    link_t1: document.getElementById('linkT1Checkbox')?.checked || false,
                    link_t2: document.getElementById('linkT2Checkbox')?.checked || false,
                    evt_test: document.getElementById('evtTestCheckbox')?.checked || false
                };
                localStorage.setItem('runtest_selections', JSON.stringify(selections));
                console.log('[Run Test] Saved selections to cache');
            } catch (e) {
                console.error('[Run Test] Error saving selections:', e);
            }
        }

        // Handle test script selection change
        function onTestScriptChange() {
            const script = document.getElementById('testScriptSelect').value;
            const uploadSection = document.getElementById('fileUploadSection');
            const testLevelSection = document.getElementById('testLevelSection');
            const testItemsSection = document.getElementById('testItemsSection');
            const topologyTypeSection = document.getElementById('topologyTypeSection');
            const topologyFileSection = document.getElementById('topologyFileSection');
            const topologyTypeLabel = document.getElementById('topologyTypeLabel');
            const topologyFileLabel = document.getElementById('topologyFileLabel');
            const topologySelect = document.getElementById('topologyTypeSelect');

            // Save selection
            if (script) {
                localStorage.setItem('runtest_script', script);
            }

            // Reset visibility
            uploadSection.style.display = 'none';
            testLevelSection.style.display = 'none';
            testItemsSection.style.display = 'none';
            topologyTypeSection.style.display = 'none';
            topologyFileSection.style.display = 'none';

            // Reset topology select to single mode by default
            topologySelect.removeAttribute('multiple');
            topologySelect.style.minHeight = 'auto';

            // Show relevant sections based on script
            if (script === 'run_all_test.sh') {
                // run_all_test.sh: bin, test_items, topology_type, topology_file
                uploadSection.style.display = 'block';
                testItemsSection.style.display = 'block';
                topologyTypeSection.style.display = 'block';
                topologyFileSection.style.display = 'block';
                topologyTypeLabel.textContent = '5. Topology Type';
                topologyFileLabel.textContent = '6. Topology File Name list';
            } else if (script === 'SAI_TX_test.sh' || script === 'Agent_HW_TX_test.sh') {
                // SAI_TX_test.sh / Agent_HW_TX_test.sh: bin, test_level
                testLevelSection.style.display = 'block';
                topologyFileSection.style.display = 'block';
                // Restore test level
                const savedLevel = localStorage.getItem('runtest_test_level');
                if (savedLevel) {
                    document.getElementById('testLevelSelect').value = savedLevel;
                }
            } else if (script === 'Link_T0_test.sh' || script === 'Link_T1_test.sh') {
                // Link_T0_test.sh / Link_T1_test.sh: bin, topology_name
                topologyTypeSection.style.display = 'block';
                topologyFileSection.style.display = 'block';
                topologyTypeLabel.textContent = '3. Topology Name';
            } else if (script === 'ExitEVT.sh') {
                // ExitEVT.sh: bin, topology_name
                topologyTypeSection.style.display = 'block';
                topologyFileSection.style.display = 'block';
                topologyTypeLabel.textContent = '3. Topology Name';
            } else if (script === 'Prbs_test.sh') {
                // Prbs_test.sh: bin, topology_file
                topologyFileSection.style.display = 'block';
            }
        }

        // Upload bin file
        function uploadBinFile() {
            const fileInput = document.getElementById('binFileInput');
            const statusDiv = document.getElementById('uploadStatus');
            const progressContainer = document.getElementById('uploadProgressContainer');
            const progressBar = document.getElementById('uploadProgressBar');
            const progressPercentage = document.getElementById('uploadPercentage');

            if (!fileInput.files || fileInput.files.length === 0) {
                statusDiv.textContent = '‚ùå Please select a file';
                statusDiv.style.color = '#F44336';
                return;
            }

            const file = fileInput.files[0];
            const formData = new FormData();
            formData.append('file', file);

            // Reset UI
            statusDiv.textContent = '‚è≥ Uploading...';
            statusDiv.style.color = '#FFC107';
            progressContainer.style.display = 'block';
            progressPercentage.style.display = 'block';
            progressBar.style.width = '0%';
            progressPercentage.textContent = '0%';

            // Use XMLHttpRequest for progress tracking
            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const percentComplete = Math.round((e.loaded / e.total) * 100);
                    progressBar.style.width = percentComplete + '%';
                    progressPercentage.textContent = percentComplete + '%';
                }
            });

            xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const data = JSON.parse(xhr.responseText);
                        if (data.success) {
                            statusDiv.textContent = `‚úÖ ${data.message}`;
                            statusDiv.style.color = '#4CAF50';

                            // Visual completion
                            progressBar.style.width = '100%';
                            progressPercentage.textContent = '100%';

                            newBinUploaded = true;
                            // Refresh bin list
                            loadBinFiles();
                            // Auto-select the uploaded file
                            setTimeout(() => {
                                document.getElementById('binFileSelect').value = data.filename;
                                // Hide progress bar after delay
                                setTimeout(() => {
                                    progressContainer.style.display = 'none';
                                    progressPercentage.style.display = 'none';
                                }, 2000);
                            }, 500);
                        } else {
                            statusDiv.textContent = `‚ùå ${data.error}`;
                            statusDiv.style.color = '#F44336';
                            progressContainer.style.display = 'none';
                            progressPercentage.style.display = 'none';
                        }
                    } catch (e) {
                        statusDiv.textContent = `‚ùå Invalid response: ${xhr.responseText}`;
                        statusDiv.style.color = '#F44336';
                    }
                } else {
                    statusDiv.textContent = `‚ùå Upload failed (HTTP ${xhr.status})`;
                    statusDiv.style.color = '#F44336';
                    progressContainer.style.display = 'none';
                    progressPercentage.style.display = 'none';
                }
            });

            xhr.addEventListener('error', () => {
                statusDiv.textContent = '‚ùå Network error occurred';
                statusDiv.style.color = '#F44336';
                progressContainer.style.display = 'none';
                progressPercentage.style.display = 'none';
            });

            xhr.open('POST', '/api/test/upload-bin');
            xhr.send(formData);
        }

        // Start test execution
        function startTest() {
            const script = document.getElementById('testScriptSelect').value;
            const bin = document.getElementById('binFileSelect').value;
            const testLevel = document.getElementById('testLevelSelect').value;
            const topologySelect = document.getElementById('topologyTypeSelect');
            const topology = Array.from(topologySelect.selectedOptions).map(opt => opt.value).filter(v => v).join(',');
            const topologyFile = document.getElementById('topologyFileSelect').value;

            // Save all selections to localStorage
            if (script) localStorage.setItem('runtest_script', script);
            if (bin) localStorage.setItem('runtest_bin', bin);
            if (testLevel) localStorage.setItem('runtest_test_level', testLevel);
            if (topology) localStorage.setItem('runtest_topology', topology);
            if (topologyFile) localStorage.setItem('runtest_topology_file', topologyFile);

            // Save clean_fboss checkbox state
            const cleanFboss = document.getElementById('cleanFbossCheckbox').checked;
            localStorage.setItem('runtest_clean_fboss', cleanFboss);

            // Validation based on script type
            if (!script) {
                alert('Please select a test script');
                return;
            }
            if (!bin) {
                alert('Please select a bin file');
                return;
            }

            // Script-specific validation
            if (script === 'SAI_TX_test.sh' || script === 'Agent_HW_TX_test.sh') {
                if (!testLevel) {
                    alert('Please select a test level (T0 or T1)');
                    return;
                }
            } else if (script === 'Link_T0_test.sh') {
                if (!topology) {
                    alert('Please select a topology name');
                    return;
                }
            } else if (script === 'ExitEVT.sh') {
                if (!topology) {
                    alert('Please select a topology name');
                    return;
                }
            } else if (script === 'run_all_test.sh') {
                if (!topology) {
                    alert('Please select a topology type');
                    return;
                }
                if (!topologyFile) {
                    alert('Please select a topology file');
                    return;
                }
            }

            const startBtn = document.getElementById('startTestBtn');
            startBtn.disabled = true;
            startBtn.textContent = '‚è≥ Starting Test...';

            // Prepare request data based on script type
            let requestData = {
                script: script,
                bin: bin,
                new_bin_uploaded: newBinUploaded,
                clean_fboss: document.getElementById('cleanFbossCheckbox').checked
            };

            // Collect test items for run_all_test.sh
            if (script === 'run_all_test.sh') {
                const testItems = {};

                // Use flat format (sai_t0, agent_t0) for reliability
                const saiTestCheckbox = document.getElementById('saiTestCheckbox');
                if (saiTestCheckbox && saiTestCheckbox.checked) {
                    const saiT0 = document.getElementById('saiT0Checkbox');
                    const saiT1 = document.getElementById('saiT1Checkbox');
                    const saiT2 = document.getElementById('saiT2Checkbox');
                    if (saiT0) testItems.sai_t0 = saiT0.checked;
                    if (saiT1) testItems.sai_t1 = saiT1.checked;
                    if (saiT2) testItems.sai_t2 = saiT2.checked;
                }

                const agentHwTestCheckbox = document.getElementById('agentHwTestCheckbox');
                if (agentHwTestCheckbox && agentHwTestCheckbox.checked) {
                    const agentT0 = document.getElementById('agentT0Checkbox');
                    const agentT1 = document.getElementById('agentT1Checkbox');
                    const agentT2 = document.getElementById('agentT2Checkbox');
                    if (agentT0) testItems.agent_t0 = agentT0.checked;
                    if (agentT1) testItems.agent_t1 = agentT1.checked;
                    if (agentT2) testItems.agent_t2 = agentT2.checked;
                }

                const linkTestCheckbox = document.getElementById('linkTestCheckbox');
                if (linkTestCheckbox && linkTestCheckbox.checked) {
                    const linkT0 = document.getElementById('linkT0Checkbox');
                    const linkT1 = document.getElementById('linkT1Checkbox');
                    const linkT2 = document.getElementById('linkT2Checkbox');
                    if (linkT0) testItems.link_t0 = linkT0.checked;
                    if (linkT1) testItems.link_t1 = linkT1.checked;
                    if (linkT2) testItems.link_t2 = linkT2.checked;
                }

                const evtTestCheckbox = document.getElementById('evtTestCheckbox');
                if (evtTestCheckbox && evtTestCheckbox.checked) {
                    testItems.evt_exit = true;
                }

                // Debug logging
                console.log('[DEBUG] Collected test items:', testItems);

                requestData.test_items = testItems;
            }

            // Add parameters based on script type
            if (script === 'SAI_TX_test.sh' || script === 'Agent_HW_TX_test.sh') {
                requestData.test_level = testLevel;
            } else if (script === 'Link_T0_test.sh' || script === 'ExitEVT.sh' || script === 'run_all_test.sh') {
                requestData.topology = topology;
                if (script === 'run_all_test.sh') {
                    requestData.topology_file = topologyFile;
                }
            }

            // Function to proceed with starting the test after topology apply (if needed)
            const proceedToStartTest = () => {
                startBtn.textContent = '‚è≥ Starting Test...';

                fetch('/api/test/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Display REST API commands
                            if (data.curl_text) {
                                document.getElementById('restApiDisplay').textContent = data.curl_text;
                                document.getElementById('restApiSection').style.display = 'block';
                            }

                            // Reset new bin uploaded flag
                            newBinUploaded = false;

                            // Freeze controls since test is starting
                            freezeTestControls();

                            // Show success message
                            alert(`‚úÖ ${data.message}\n\nTest started successfully! Switching to Test Info tab...`);

                            // Switch to Test Info tab
                            setTimeout(() => {
                                switchTab('testinfo');
                            }, 1000);
                        } else {
                            alert(`‚ùå Failed to start test:\n${data.error}`);
                        }
                    })
                    .catch(err => {
                        alert(`‚ùå Error starting test:\n${err.message}`);
                    })
                    .finally(() => {
                        startBtn.disabled = false;
                        startBtn.textContent = '‚ñ∂Ô∏è Start Test';
                    });
            };

            // If a topology file is selected, apply it first
            if (topologyFile) {
                startBtn.textContent = '‚öôÔ∏è Applying Topology...';

                const applyData = {
                    platform: currentPlatform,
                    config_filename: topologyFile
                };

                fetch('/api/apply_topology', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(applyData)
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('Topology applied successfully');
                            proceedToStartTest();
                        } else {
                            alert(`‚ùå Topology application failed:\n${data.error || 'Unknown error'}\n\nAborting test start.`);
                            startBtn.disabled = false;
                            startBtn.textContent = '‚ñ∂Ô∏è Start Test';
                        }
                    })
                    .catch(err => {
                        alert(`‚ùå Error applying topology:\n${err.message}\n\nAborting test start.`);
                        startBtn.disabled = false;
                        startBtn.textContent = '‚ñ∂Ô∏è Start Test';
                    });
            } else {
                // No topology file selected, proceed directly to starting the test
                proceedToStartTest();
            }
        }

        // Copy REST API commands to clipboard
        function copyRestApiCommands() {
            const text = document.getElementById('restApiDisplay').textContent;
            navigator.clipboard.writeText(text)
                .then(() => {
                    alert('‚úÖ REST API commands copied to clipboard!');
                })
                .catch(err => {
                    alert('‚ùå Failed to copy: ' + err.message);
                });
        }

        // Show CURL commands modal
        function showCurlCommands() {
            const script = document.getElementById('testScriptSelect').value;
            const bin = document.getElementById('binFileSelect').value;
            const testLevel = document.getElementById('testLevelSelect').value;
            const topology = document.getElementById('topologyTypeSelect').value;
            const topologyFile = document.getElementById('topologyFileSelect').value;
            const cleanFboss = document.getElementById('cleanFbossCheckbox').checked;

            if (!script || !bin) {
                alert('‚ö†Ô∏è Please select at least a test script and bin file first');
                return;
            }

            // Build request data
            let requestData = {
                script: script,
                bin: bin,
                clean_fboss: cleanFboss
            };

            if (testLevel) {
                requestData.test_level = testLevel;
            }
            if (topology) {
                requestData.topology = topology;
            }
            if (topologyFile) {
                requestData.topology_file = topologyFile;
            }

            // Collect test items for run_all_test.sh
            if (script === 'run_all_test.sh') {
                const testItems = {};

                const saiTestCheckbox = document.getElementById('saiTestCheckbox');
                if (saiTestCheckbox && saiTestCheckbox.checked) {
                    const saiT0 = document.getElementById('saiT0Checkbox');
                    const saiT1 = document.getElementById('saiT1Checkbox');
                    const saiT2 = document.getElementById('saiT2Checkbox');
                    if (saiT0) testItems.sai_t0 = saiT0.checked;
                    if (saiT1) testItems.sai_t1 = saiT1.checked;
                    if (saiT2) testItems.sai_t2 = saiT2.checked;
                }

                const agentHwTestCheckbox = document.getElementById('agentHwTestCheckbox');
                if (agentHwTestCheckbox && agentHwTestCheckbox.checked) {
                    const agentT0 = document.getElementById('agentT0Checkbox');
                    const agentT1 = document.getElementById('agentT1Checkbox');
                    const agentT2 = document.getElementById('agentT2Checkbox');
                    if (agentT0) testItems.agent_t0 = agentT0.checked;
                    if (agentT1) testItems.agent_t1 = agentT1.checked;
                    if (agentT2) testItems.agent_t2 = agentT2.checked;
                }

                const linkTestCheckbox = document.getElementById('linkTestCheckbox');
                if (linkTestCheckbox && linkTestCheckbox.checked) {
                    const linkT0 = document.getElementById('linkT0Checkbox');
                    const linkT1 = document.getElementById('linkT1Checkbox');
                    const linkT2 = document.getElementById('linkT2Checkbox');
                    if (linkT0) testItems.link_t0 = linkT0.checked;
                    if (linkT1) testItems.link_t1 = linkT1.checked;
                    if (linkT2) testItems.link_t2 = linkT2.checked;
                }

                const evtTestCheckbox = document.getElementById('evtTestCheckbox');
                if (evtTestCheckbox && evtTestCheckbox.checked) {
                    testItems.evt_exit = true;
                }

                if (Object.keys(testItems).length > 0) {
                    requestData.test_items = testItems;
                }
            }

            // Generate CURL command
            const jsonData = JSON.stringify(requestData, null, 2);
            // Get actual DUT IP from current page location
            const dutIp = window.location.hostname || 'localhost';

            let curlCommand = "";

            // Step 1: Apply Topology (if applicable)
            if (topologyFile) {
                curlCommand += `# Step 1: Apply Topology (Required before starting test)\n`;
                curlCommand += `curl -X POST http://${dutIp}:5000/api/apply_topology \\\n`;
                curlCommand += `  -H "Content-Type: application/json" \\\n`;
                curlCommand += `  -d '{"platform": "${currentPlatform}", "config_filename": "${topologyFile}"}'\n\n`;
            } else {
                curlCommand += `# Note: No topology file selected. ensure topology is applied if needed.\n\n`;
            }

            // Step 2: Start Test
            curlCommand += `# Step 2: Start Test Execution\ncurl -X POST http://${dutIp}:5000/api/test/start \\\n`;
            curlCommand += `  -H "Content-Type: application/json" \\\n`;
            curlCommand += `  -d '${jsonData}'\n\n`;

            // Display in modal
            document.getElementById('curlCommandDisplay').textContent = curlCommand;
            document.getElementById('curlModal').style.display = 'block';
        }

        // Close CURL commands modal
        function closeCurlModal() {
            document.getElementById('curlModal').style.display = 'none';
            document.getElementById('curlCopyStatus').textContent = '';
        }

        // Copy CURL command to clipboard
        function copyCurlCommand() {
            const text = document.getElementById('curlCommandDisplay').textContent;
            const statusDiv = document.getElementById('curlCopyStatus');

            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        statusDiv.textContent = '‚úÖ Commands copied to clipboard!';
                        statusDiv.style.color = '#4CAF50';
                        setTimeout(() => {
                            statusDiv.textContent = '';
                        }, 3000);
                    })
                    .catch(err => {
                        // Fallback to textarea method
                        copyToClipboardFallback(text, statusDiv);
                    });
            } else {
                // Use fallback for older browsers
                copyToClipboardFallback(text, statusDiv);
            }
        }

        // Fallback copy method using textarea
        function copyToClipboardFallback(text, statusDiv) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    statusDiv.textContent = '‚úÖ Commands copied to clipboard!';
                    statusDiv.style.color = '#4CAF50';
                    setTimeout(() => {
                        statusDiv.textContent = '';
                    }, 3000);
                } else {
                    statusDiv.textContent = '‚ùå Failed to copy. Please copy manually.';
                    statusDiv.style.color = '#F44336';
                }
            } catch (err) {
                statusDiv.textContent = '‚ùå Copy not supported. Please copy manually.';
                statusDiv.style.color = '#F44336';
            } finally {
                document.body.removeChild(textarea);
            }
        }

        // Close modal when clicking outside of it
        window.onclick = function (event) {
            const modal = document.getElementById('curlModal');
            if (event.target === modal) {
                closeCurlModal();
            }
        }

        // Start test status checking
        function startTestStatusCheck() {
            // Clear any existing timer
            if (testStatusCheckTimer) {
                clearInterval(testStatusCheckTimer);
            }

            // Check immediately
            checkTestStatus();

            // Check every 3 seconds
            testStatusCheckTimer = setInterval(checkTestStatus, 3000);
        }

        // Check test status
        function checkTestStatus() {
            fetch('/api/test/status')
                .then(response => response.json())
                .then(data => {
                    const indicator = document.getElementById('testRunningIndicator');
                    const runTestTabBtn = document.querySelectorAll('.tab-btn')[3]; // Run Test is 4th tab (index 3)

                    if (data.running) {
                        indicator.style.display = 'block';
                        freezeTestControls();
                        // Add red border flash animation to Run Test tab
                        if (runTestTabBtn) {
                            runTestTabBtn.classList.add('test-running');
                        }
                    } else {
                        indicator.style.display = 'none';
                        unfreezeTestControls();
                        // Remove red border flash animation from Run Test tab
                        if (runTestTabBtn) {
                            runTestTabBtn.classList.remove('test-running');
                        }
                    }
                })
                .catch(err => {
                    console.error('Error checking test status:', err);
                });
        }

        // Freeze all test controls when test is running
        function freezeTestControls() {
            // Disable all input controls
            document.getElementById('testScriptSelect').disabled = true;
            document.getElementById('binFileSelect').disabled = true;
            document.getElementById('testLevelSelect').disabled = true;
            document.getElementById('topologyTypeSelect').disabled = true;
            document.getElementById('topologyFileSelect').disabled = true;
            document.getElementById('binFileInput').disabled = true;

            // Disable test item checkboxes
            const saiTestCheckbox = document.getElementById('saiTestCheckbox');
            const agentHwTestCheckbox = document.getElementById('agentHwTestCheckbox');
            const linkTestCheckbox = document.getElementById('linkTestCheckbox');
            const evtTestCheckbox = document.getElementById('evtTestCheckbox');
            if (saiTestCheckbox) saiTestCheckbox.disabled = true;
            if (agentHwTestCheckbox) agentHwTestCheckbox.disabled = true;
            if (linkTestCheckbox) linkTestCheckbox.disabled = true;
            if (evtTestCheckbox) evtTestCheckbox.disabled = true;

            // Disable child test level checkboxes
            document.querySelectorAll('.sai-level').forEach(cb => cb.disabled = true);
            document.querySelectorAll('.agenthw-level').forEach(cb => cb.disabled = true);
            document.querySelectorAll('.link-level').forEach(cb => {
                if (!cb.hasAttribute('disabled')) cb.disabled = true;
            });

            // Hide Start button, show Stop button
            document.getElementById('startTestBtn').style.display = 'none';
            document.getElementById('stopTestBtn').style.display = 'inline-block';

            // Disable upload button if visible
            const uploadBtns = document.querySelectorAll('#fileUploadSection button');
            uploadBtns.forEach(btn => btn.disabled = true);
        }

        // Unfreeze all test controls when test is stopped
        function unfreezeTestControls() {
            // Enable all input controls
            document.getElementById('testScriptSelect').disabled = false;
            document.getElementById('binFileSelect').disabled = false;
            document.getElementById('testLevelSelect').disabled = false;
            document.getElementById('topologyTypeSelect').disabled = false;
            document.getElementById('topologyFileSelect').disabled = false;
            document.getElementById('binFileInput').disabled = false;

            // Enable test item checkboxes
            const saiTestCheckbox = document.getElementById('saiTestCheckbox');
            const agentHwTestCheckbox = document.getElementById('agentHwTestCheckbox');
            const linkTestCheckbox = document.getElementById('linkTestCheckbox');
            const evtTestCheckbox = document.getElementById('evtTestCheckbox');
            if (saiTestCheckbox) saiTestCheckbox.disabled = false;
            if (agentHwTestCheckbox) agentHwTestCheckbox.disabled = false;
            if (linkTestCheckbox) linkTestCheckbox.disabled = false;
            if (evtTestCheckbox) evtTestCheckbox.disabled = false;

            // Enable child test level checkboxes
            document.querySelectorAll('.sai-level').forEach(cb => cb.disabled = false);
            document.querySelectorAll('.agenthw-level').forEach(cb => cb.disabled = false);
            document.querySelectorAll('.link-level').forEach(cb => {
                if (!cb.hasAttribute('disabled')) cb.disabled = false;
            });

            // Show Start button, hide Stop button
            document.getElementById('startTestBtn').style.display = 'inline-block';
            document.getElementById('stopTestBtn').style.display = 'none';

            // Enable upload button if visible
            const uploadBtns = document.querySelectorAll('#fileUploadSection button');
            uploadBtns.forEach(btn => btn.disabled = false);
        }

        // Stop current test execution
        function stopTest() {
            if (!confirm('‚ö†Ô∏è Are you sure you want to stop the current test?\n\nThis will terminate all test processes.')) {
                return;
            }

            const stopBtn = document.getElementById('stopTestBtn');
            stopBtn.disabled = true;
            stopBtn.textContent = '‚è≥ Stopping...';

            fetch('/api/test/kill-processes', {
                method: 'POST'
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert(`‚úÖ Test stopped successfully!\n\nKilled ${data.killed.length} processes.`);
                        // Unfreeze controls
                        unfreezeTestControls();
                        // Hide test running indicator
                        document.getElementById('testRunningIndicator').style.display = 'none';
                    } else {
                        alert(`‚ùå Failed to stop test:\n${data.error}`);
                    }
                })
                .catch(err => {
                    alert(`‚ùå Error stopping test:\n${err.message}`);
                })
                .finally(() => {
                    stopBtn.disabled = false;
                    stopBtn.textContent = '‚èπÔ∏è Stop Test';
                });
        }

        // ============================================================================
        // Test Procedure Save/Load Functions
        // ============================================================================

        // Load saved test procedures
        function loadSavedProcedures() {
            fetch('/api/test/procedures')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('savedProcedureSelect');
                    select.innerHTML = '<option value="">-- Select Saved Procedure --</option>';

                    if (data.procedures && data.procedures.length > 0) {
                        data.procedures.forEach(proc => {
                            const option = document.createElement('option');
                            option.value = proc;
                            option.textContent = proc;
                            select.appendChild(option);
                        });
                    }
                })
                .catch(err => console.error('Error loading saved procedures:', err));
        }

        // Refresh saved procedures list
        function refreshSavedProcedures() {
            loadSavedProcedures();
        }

        // Delete a saved test procedure
        function deleteSavedProcedure() {
            const procedureName = document.getElementById('savedProcedureSelect').value;

            if (!procedureName) {
                alert('‚ö†Ô∏è Please select a procedure to delete');
                return;
            }

            if (!confirm(`‚ö†Ô∏è Are you sure you want to delete the test procedure "${procedureName}"?\n\nThis action cannot be undone.`)) {
                return;
            }

            fetch(`/api/test/procedures/${encodeURIComponent(procedureName)}`, {
                method: 'DELETE'
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert(`‚úÖ ${data.message}`);
                        // Clear selection
                        document.getElementById('savedProcedureSelect').value = '';
                        // Refresh procedures list
                        loadSavedProcedures();
                    } else {
                        alert(`‚ùå Failed to delete procedure:\n${data.error}`);
                    }
                })
                .catch(err => {
                    alert(`‚ùå Error deleting procedure:\n${err.message}`);
                });
        }

        // Load a saved test procedure
        function loadSavedProcedure() {
            const procedureName = document.getElementById('savedProcedureSelect').value;
            if (!procedureName) return;

            fetch(`/api/test/procedures/${encodeURIComponent(procedureName)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Populate form fields with saved procedure data
                        const config = data.config;

                        // Switch platform if saved in procedure
                        if (config.platform && config.platform !== currentPlatform) {
                            console.log('[Procedure] Switching platform from', currentPlatform, 'to', config.platform);
                            switchPlatform(config.platform);
                        }

                        // Refresh topology files for the platform, then set values
                        if (config.platform) {
                            loadTopologyFiles(config.platform).then(() => {
                                // Now that files are loaded, set the topology file value
                                if (config.topology_file) {
                                    const select = document.getElementById('topologyFileSelect');
                                    select.value = config.topology_file;
                                    console.log('[Procedure] Set topology file:', config.topology_file);

                                    // Verify if the value was set successfully
                                    if (select.value !== config.topology_file) {
                                        console.warn('[Procedure] Topology file not found in list:', config.topology_file);
                                    }
                                }
                            });
                        }

                        if (config.script) {
                            document.getElementById('testScriptSelect').value = config.script;
                            onTestScriptChange(); // Trigger to show/hide sections
                        }
                        if (config.bin) {
                            document.getElementById('binFileSelect').value = config.bin;
                        }
                        if (config.test_level) {
                            document.getElementById('testLevelSelect').value = config.test_level;
                        }

                        // Wait a bit for topology types to load, then set other values
                        setTimeout(() => {
                            if (config.topology) {
                                document.getElementById('topologyTypeSelect').value = config.topology;
                                console.log('[Procedure] Set topology type:', config.topology);
                            }
                            if (config.clean_fboss !== undefined) {
                                document.getElementById('cleanFbossCheckbox').checked = config.clean_fboss;
                            }

                            // Restore test items if available
                            if (config.test_items) {
                                const items = config.test_items;

                                // SAI Test - restore parent checkbox first
                                if (items.sai_test !== undefined) {
                                    const saiTestCheckbox = document.getElementById('saiTestCheckbox');
                                    if (saiTestCheckbox) {
                                        saiTestCheckbox.checked = items.sai_test;
                                        toggleTestLevels('sai'); // Show/hide child checkboxes
                                        // Then restore child checkboxes
                                        if (items.sai_t0 !== undefined) document.getElementById('saiT0Checkbox').checked = items.sai_t0;
                                        if (items.sai_t1 !== undefined) document.getElementById('saiT1Checkbox').checked = items.sai_t1;
                                        if (items.sai_t2 !== undefined) document.getElementById('saiT2Checkbox').checked = items.sai_t2;
                                    }
                                }

                                // Agent HW Test - restore parent checkbox first
                                if (items.agent_hw_test !== undefined) {
                                    const agentHwTestCheckbox = document.getElementById('agentHwTestCheckbox');
                                    if (agentHwTestCheckbox) {
                                        agentHwTestCheckbox.checked = items.agent_hw_test;
                                        toggleTestLevels('agenthw'); // Show/hide child checkboxes
                                        // Then restore child checkboxes
                                        if (items.agent_t0 !== undefined) document.getElementById('agentT0Checkbox').checked = items.agent_t0;
                                        if (items.agent_t1 !== undefined) document.getElementById('agentT1Checkbox').checked = items.agent_t1;
                                        if (items.agent_t2 !== undefined) document.getElementById('agentT2Checkbox').checked = items.agent_t2;
                                    }
                                }

                                // Link Test - restore parent checkbox first
                                if (items.link_test !== undefined) {
                                    const linkTestCheckbox = document.getElementById('linkTestCheckbox');
                                    if (linkTestCheckbox) {
                                        linkTestCheckbox.checked = items.link_test;
                                        toggleTestLevels('link'); // Show/hide child checkboxes
                                        // Then restore child checkboxes
                                        if (items.link_t0 !== undefined) {
                                            const cb = document.getElementById('linkT0Checkbox');
                                            if (cb) cb.checked = items.link_t0;
                                        }
                                        if (items.link_t1 !== undefined) {
                                            const cb = document.getElementById('linkT1Checkbox');
                                            if (cb && !cb.disabled) cb.checked = items.link_t1;
                                        }
                                        if (items.link_t2 !== undefined) {
                                            const cb = document.getElementById('linkT2Checkbox');
                                            if (cb && !cb.disabled) cb.checked = items.link_t2;
                                        }
                                    }
                                }

                                // EVT Exit Test
                                if (items.evt_exit !== undefined) {
                                    const evtTestCheckbox = document.getElementById('evtTestCheckbox');
                                    if (evtTestCheckbox) {
                                        evtTestCheckbox.checked = items.evt_exit;
                                    }
                                }

                                console.log('[Procedure] Restored test items:', items);
                            }
                        }, 500);

                        alert(`‚úÖ Loaded test procedure: ${procedureName}\n\nPlatform: ${config.platform || 'N/A'}\nScript: ${config.script}\nBin: ${config.bin}\nTopology: ${config.topology || 'N/A'}\nTopology File: ${config.topology_file || 'N/A'}`);
                    } else {
                        alert(`‚ùå Failed to load procedure:\n${data.error}`);
                    }
                })
                .catch(err => {
                    alert(`‚ùå Error loading procedure:\n${err.message}`);
                });
        }

        // Save current test procedure
        function saveTestProcedure() {
            const procedureName = document.getElementById('procedureNameInput').value.trim();
            const statusDiv = document.getElementById('saveProcedureStatus');

            if (!procedureName) {
                statusDiv.textContent = '‚ùå Please enter a procedure name';
                statusDiv.style.color = '#F44336';
                return;
            }

            // Collect current configuration
            const topology = document.getElementById('topologyTypeSelect').value;

            // Collect test items - save ALL checkbox states (checked and unchecked)
            const testItems = {};

            // SAI Test - always save parent and child checkbox states
            const saiTestCheckbox = document.getElementById('saiTestCheckbox');
            if (saiTestCheckbox) {
                testItems.sai_test = saiTestCheckbox.checked;
                const saiT0 = document.getElementById('saiT0Checkbox');
                const saiT1 = document.getElementById('saiT1Checkbox');
                const saiT2 = document.getElementById('saiT2Checkbox');
                if (saiT0) testItems.sai_t0 = saiT0.checked;
                if (saiT1) testItems.sai_t1 = saiT1.checked;
                if (saiT2) testItems.sai_t2 = saiT2.checked;
            }

            // Agent HW Test - always save parent and child checkbox states
            const agentHwTestCheckbox = document.getElementById('agentHwTestCheckbox');
            if (agentHwTestCheckbox) {
                testItems.agent_hw_test = agentHwTestCheckbox.checked;
                const agentT0 = document.getElementById('agentT0Checkbox');
                const agentT1 = document.getElementById('agentT1Checkbox');
                const agentT2 = document.getElementById('agentT2Checkbox');
                if (agentT0) testItems.agent_t0 = agentT0.checked;
                if (agentT1) testItems.agent_t1 = agentT1.checked;
                if (agentT2) testItems.agent_t2 = agentT2.checked;
            }

            // Link Test - always save parent and child checkbox states
            const linkTestCheckbox = document.getElementById('linkTestCheckbox');
            if (linkTestCheckbox) {
                testItems.link_test = linkTestCheckbox.checked;
                const linkT0 = document.getElementById('linkT0Checkbox');
                const linkT1 = document.getElementById('linkT1Checkbox');
                const linkT2 = document.getElementById('linkT2Checkbox');
                if (linkT0) testItems.link_t0 = linkT0.checked;
                if (linkT1 && !linkT1.disabled) testItems.link_t1 = linkT1.checked;
                if (linkT2 && !linkT2.disabled) testItems.link_t2 = linkT2.checked;
            }

            // EVT Exit Test - always save checkbox state
            const evtTestCheckbox = document.getElementById('evtTestCheckbox');
            if (evtTestCheckbox) {
                testItems.evt_exit = evtTestCheckbox.checked;
            }

            const config = {
                platform: currentPlatform,  // Save current platform
                script: document.getElementById('testScriptSelect').value,
                bin: document.getElementById('binFileSelect').value,
                test_level: document.getElementById('testLevelSelect').value,
                topology: topology,
                topology_file: document.getElementById('topologyFileSelect').value,
                clean_fboss: document.getElementById('cleanFbossCheckbox').checked,
                test_items: testItems  // Add test items
            };

            // Log configuration for debugging
            console.log('[Procedure Save] Configuration:', config);

            // Basic validation
            if (!config.script) {
                statusDiv.textContent = '‚ùå Please select a test script first';
                statusDiv.style.color = '#F44336';
                return;
            }
            if (!config.bin) {
                statusDiv.textContent = '‚ùå Please select a bin file first';
                statusDiv.style.color = '#F44336';
                return;
            }

            statusDiv.textContent = '‚è≥ Saving...';
            statusDiv.style.color = '#FFC107';

            fetch('/api/test/procedures', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: procedureName,
                    config: config
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        statusDiv.textContent = `‚úÖ ${data.message} (Platform: ${config.platform}, Topology: ${config.topology || 'None'}, File: ${config.topology_file || 'None'})`;
                        statusDiv.style.color = '#4CAF50';
                        console.log('[Procedure Save] Success:', data);
                        // Clear input
                        document.getElementById('procedureNameInput').value = '';
                        // Refresh procedures list
                        loadSavedProcedures();
                    } else {
                        statusDiv.textContent = `‚ùå ${data.error}`;
                        statusDiv.style.color = '#F44336';
                    }
                })
                .catch(err => {
                    statusDiv.textContent = `‚ùå Save failed: ${err.message}`;
                    statusDiv.style.color = '#F44336';
                    console.error('[Procedure Save] Error:', err);
                });
        }

    </script>
</body>

</html>